
DoorLocker_SystemMC1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000030be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ea  00800060  000030be  00003152  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  0080014a  0080014a  0000323c  2**0
                  ALLOC
  3 .stab         00002cb8  00000000  00000000  0000323c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001519  00000000  00000000  00005ef4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000740d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000754d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  000076bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00009306  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000a1f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000afa0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000b100  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000b38d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000bb5b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 fc 14 	jmp	0x29f8	; 0x29f8 <__vector_3>
      10:	0c 94 63 14 	jmp	0x28c6	; 0x28c6 <__vector_4>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 c9 14 	jmp	0x2992	; 0x2992 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 30 14 	jmp	0x2860	; 0x2860 <__vector_8>
      24:	0c 94 fd 13 	jmp	0x27fa	; 0x27fa <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 96 14 	jmp	0x292c	; 0x292c <__vector_19>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee eb       	ldi	r30, 0xBE	; 190
      68:	f0 e3       	ldi	r31, 0x30	; 48
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 34       	cpi	r26, 0x4A	; 74
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	aa e4       	ldi	r26, 0x4A	; 74
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 35       	cpi	r26, 0x5A	; 90
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 65 0b 	call	0x16ca	; 0x16ca <main>
      8a:	0c 94 5d 18 	jmp	0x30ba	; 0x30ba <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 d8 17 	jmp	0x2fb0	; 0x2fb0 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a2 e4       	ldi	r26, 0x42	; 66
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 f4 17 	jmp	0x2fe8	; 0x2fe8 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 d8 17 	jmp	0x2fb0	; 0x2fb0 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	82 e4       	ldi	r24, 0x42	; 66
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 f4 17 	jmp	0x2fe8	; 0x2fe8 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 e8 17 	jmp	0x2fd0	; 0x2fd0 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 04 18 	jmp	0x3008	; 0x3008 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__pack_f+0x178>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__pack_f+0x172>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__pack_f+0x17c>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__pack_f+0x114>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__pack_f+0x76>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__pack_f+0xca>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__pack_f+0x86>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__pack_f+0x7e>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__pack_f+0x9c>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__pack_f+0x94>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__pack_f+0xbe>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__pack_f+0xee>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__pack_f+0xf6>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__pack_f+0xf6>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__pack_f+0x10e>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__pack_f+0x162>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__pack_f+0x172>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__pack_f+0x144>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__pack_f+0x154>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__pack_f+0x14c>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__pack_f+0x162>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__pack_f+0x164>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__pack_f+0x17c>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <KeyPad_getPressedKey>:
#endif

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
uint8 KeyPad_getPressedKey(void){
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <KeyPad_getPressedKey+0x6>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
	uint8 col,row;
	while(1)
	{
		for(col=0;col<N_col;col++) /* loop for columns */
     b50:	1a 82       	std	Y+2, r1	; 0x02
     b52:	4c c0       	rjmp	.+152    	; 0xbec <KeyPad_getPressedKey+0xa6>
		{
			/*
			 * each time only one of the column pins will be output and
			 * the rest will be input pins include the row pins
			 */
			KEYPAD_PORT_DIR = (0b00010000<<col);
     b54:	ea e3       	ldi	r30, 0x3A	; 58
     b56:	f0 e0       	ldi	r31, 0x00	; 0
     b58:	8a 81       	ldd	r24, Y+2	; 0x02
     b5a:	28 2f       	mov	r18, r24
     b5c:	30 e0       	ldi	r19, 0x00	; 0
     b5e:	80 e1       	ldi	r24, 0x10	; 16
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	02 c0       	rjmp	.+4      	; 0xb68 <KeyPad_getPressedKey+0x22>
     b64:	88 0f       	add	r24, r24
     b66:	99 1f       	adc	r25, r25
     b68:	2a 95       	dec	r18
     b6a:	e2 f7       	brpl	.-8      	; 0xb64 <KeyPad_getPressedKey+0x1e>
     b6c:	80 83       	st	Z, r24

			/*
			 * clear the output pin column in this trace and enable the internal
			 * pull up resistors for the rows pins
			 */
			KEYPAD_PORT_OUT = (~(0b00010000<<col));
     b6e:	eb e3       	ldi	r30, 0x3B	; 59
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	8a 81       	ldd	r24, Y+2	; 0x02
     b74:	28 2f       	mov	r18, r24
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	80 e1       	ldi	r24, 0x10	; 16
     b7a:	90 e0       	ldi	r25, 0x00	; 0
     b7c:	02 2e       	mov	r0, r18
     b7e:	02 c0       	rjmp	.+4      	; 0xb84 <KeyPad_getPressedKey+0x3e>
     b80:	88 0f       	add	r24, r24
     b82:	99 1f       	adc	r25, r25
     b84:	0a 94       	dec	r0
     b86:	e2 f7       	brpl	.-8      	; 0xb80 <KeyPad_getPressedKey+0x3a>
     b88:	80 95       	com	r24
     b8a:	80 83       	st	Z, r24
			for(row=0;row<N_row;row++) /* loop for rows */
     b8c:	19 82       	std	Y+1, r1	; 0x01
     b8e:	28 c0       	rjmp	.+80     	; 0xbe0 <KeyPad_getPressedKey+0x9a>
			{
				if(BIT_IS_CLEAR(KEYPAD_PORT_IN,row)) /* if the switch is press in this row */
     b90:	e9 e3       	ldi	r30, 0x39	; 57
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	80 81       	ld	r24, Z
     b96:	28 2f       	mov	r18, r24
     b98:	30 e0       	ldi	r19, 0x00	; 0
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	88 2f       	mov	r24, r24
     b9e:	90 e0       	ldi	r25, 0x00	; 0
     ba0:	a9 01       	movw	r20, r18
     ba2:	02 c0       	rjmp	.+4      	; 0xba8 <KeyPad_getPressedKey+0x62>
     ba4:	55 95       	asr	r21
     ba6:	47 95       	ror	r20
     ba8:	8a 95       	dec	r24
     baa:	e2 f7       	brpl	.-8      	; 0xba4 <KeyPad_getPressedKey+0x5e>
     bac:	ca 01       	movw	r24, r20
     bae:	81 70       	andi	r24, 0x01	; 1
     bb0:	90 70       	andi	r25, 0x00	; 0
     bb2:	00 97       	sbiw	r24, 0x00	; 0
     bb4:	91 f4       	brne	.+36     	; 0xbda <KeyPad_getPressedKey+0x94>
				{
					#if (N_col == 3)
						return KeyPad_4x3_adjustKeyNumber((row*N_col)+col+1);
					#elif (N_col == 4)
						return KeyPad_4x4_adjustKeyNumber((row*N_col)+col+1);
     bb6:	89 81       	ldd	r24, Y+1	; 0x01
     bb8:	88 2f       	mov	r24, r24
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	88 0f       	add	r24, r24
     bbe:	99 1f       	adc	r25, r25
     bc0:	88 0f       	add	r24, r24
     bc2:	99 1f       	adc	r25, r25
     bc4:	98 2f       	mov	r25, r24
     bc6:	8a 81       	ldd	r24, Y+2	; 0x02
     bc8:	89 0f       	add	r24, r25
     bca:	8f 5f       	subi	r24, 0xFF	; 255
     bcc:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <KeyPad_4x4_adjustKeyNumber>
					#endif
				}
			}
		}
	}
}
     bd0:	0f 90       	pop	r0
     bd2:	0f 90       	pop	r0
     bd4:	cf 91       	pop	r28
     bd6:	df 91       	pop	r29
     bd8:	08 95       	ret
			/*
			 * clear the output pin column in this trace and enable the internal
			 * pull up resistors for the rows pins
			 */
			KEYPAD_PORT_OUT = (~(0b00010000<<col));
			for(row=0;row<N_row;row++) /* loop for rows */
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	8f 5f       	subi	r24, 0xFF	; 255
     bde:	89 83       	std	Y+1, r24	; 0x01
     be0:	89 81       	ldd	r24, Y+1	; 0x01
     be2:	84 30       	cpi	r24, 0x04	; 4
     be4:	a8 f2       	brcs	.-86     	; 0xb90 <KeyPad_getPressedKey+0x4a>
 *******************************************************************************/
uint8 KeyPad_getPressedKey(void){
	uint8 col,row;
	while(1)
	{
		for(col=0;col<N_col;col++) /* loop for columns */
     be6:	8a 81       	ldd	r24, Y+2	; 0x02
     be8:	8f 5f       	subi	r24, 0xFF	; 255
     bea:	8a 83       	std	Y+2, r24	; 0x02
     bec:	8a 81       	ldd	r24, Y+2	; 0x02
     bee:	84 30       	cpi	r24, 0x04	; 4
     bf0:	08 f4       	brcc	.+2      	; 0xbf4 <KeyPad_getPressedKey+0xae>
     bf2:	b0 cf       	rjmp	.-160    	; 0xb54 <KeyPad_getPressedKey+0xe>
     bf4:	ad cf       	rjmp	.-166    	; 0xb50 <KeyPad_getPressedKey+0xa>

00000bf6 <KeyPad_4x4_adjustKeyNumber>:
}

#elif (N_col == 4)

static uint8 KeyPad_4x4_adjustKeyNumber(uint8 button_number)
{
     bf6:	df 93       	push	r29
     bf8:	cf 93       	push	r28
     bfa:	00 d0       	rcall	.+0      	; 0xbfc <KeyPad_4x4_adjustKeyNumber+0x6>
     bfc:	00 d0       	rcall	.+0      	; 0xbfe <KeyPad_4x4_adjustKeyNumber+0x8>
     bfe:	cd b7       	in	r28, 0x3d	; 61
     c00:	de b7       	in	r29, 0x3e	; 62
     c02:	89 83       	std	Y+1, r24	; 0x01
	switch(button_number)
     c04:	89 81       	ldd	r24, Y+1	; 0x01
     c06:	28 2f       	mov	r18, r24
     c08:	30 e0       	ldi	r19, 0x00	; 0
     c0a:	3c 83       	std	Y+4, r19	; 0x04
     c0c:	2b 83       	std	Y+3, r18	; 0x03
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	88 30       	cpi	r24, 0x08	; 8
     c14:	91 05       	cpc	r25, r1
     c16:	09 f4       	brne	.+2      	; 0xc1a <KeyPad_4x4_adjustKeyNumber+0x24>
     c18:	70 c0       	rjmp	.+224    	; 0xcfa <KeyPad_4x4_adjustKeyNumber+0x104>
     c1a:	2b 81       	ldd	r18, Y+3	; 0x03
     c1c:	3c 81       	ldd	r19, Y+4	; 0x04
     c1e:	29 30       	cpi	r18, 0x09	; 9
     c20:	31 05       	cpc	r19, r1
     c22:	5c f5       	brge	.+86     	; 0xc7a <KeyPad_4x4_adjustKeyNumber+0x84>
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	84 30       	cpi	r24, 0x04	; 4
     c2a:	91 05       	cpc	r25, r1
     c2c:	09 f4       	brne	.+2      	; 0xc30 <KeyPad_4x4_adjustKeyNumber+0x3a>
     c2e:	59 c0       	rjmp	.+178    	; 0xce2 <KeyPad_4x4_adjustKeyNumber+0xec>
     c30:	2b 81       	ldd	r18, Y+3	; 0x03
     c32:	3c 81       	ldd	r19, Y+4	; 0x04
     c34:	25 30       	cpi	r18, 0x05	; 5
     c36:	31 05       	cpc	r19, r1
     c38:	9c f4       	brge	.+38     	; 0xc60 <KeyPad_4x4_adjustKeyNumber+0x6a>
     c3a:	8b 81       	ldd	r24, Y+3	; 0x03
     c3c:	9c 81       	ldd	r25, Y+4	; 0x04
     c3e:	82 30       	cpi	r24, 0x02	; 2
     c40:	91 05       	cpc	r25, r1
     c42:	09 f4       	brne	.+2      	; 0xc46 <KeyPad_4x4_adjustKeyNumber+0x50>
     c44:	48 c0       	rjmp	.+144    	; 0xcd6 <KeyPad_4x4_adjustKeyNumber+0xe0>
     c46:	2b 81       	ldd	r18, Y+3	; 0x03
     c48:	3c 81       	ldd	r19, Y+4	; 0x04
     c4a:	23 30       	cpi	r18, 0x03	; 3
     c4c:	31 05       	cpc	r19, r1
     c4e:	0c f0       	brlt	.+2      	; 0xc52 <KeyPad_4x4_adjustKeyNumber+0x5c>
     c50:	45 c0       	rjmp	.+138    	; 0xcdc <KeyPad_4x4_adjustKeyNumber+0xe6>
     c52:	8b 81       	ldd	r24, Y+3	; 0x03
     c54:	9c 81       	ldd	r25, Y+4	; 0x04
     c56:	81 30       	cpi	r24, 0x01	; 1
     c58:	91 05       	cpc	r25, r1
     c5a:	09 f4       	brne	.+2      	; 0xc5e <KeyPad_4x4_adjustKeyNumber+0x68>
     c5c:	39 c0       	rjmp	.+114    	; 0xcd0 <KeyPad_4x4_adjustKeyNumber+0xda>
     c5e:	67 c0       	rjmp	.+206    	; 0xd2e <KeyPad_4x4_adjustKeyNumber+0x138>
     c60:	2b 81       	ldd	r18, Y+3	; 0x03
     c62:	3c 81       	ldd	r19, Y+4	; 0x04
     c64:	26 30       	cpi	r18, 0x06	; 6
     c66:	31 05       	cpc	r19, r1
     c68:	09 f4       	brne	.+2      	; 0xc6c <KeyPad_4x4_adjustKeyNumber+0x76>
     c6a:	41 c0       	rjmp	.+130    	; 0xcee <KeyPad_4x4_adjustKeyNumber+0xf8>
     c6c:	8b 81       	ldd	r24, Y+3	; 0x03
     c6e:	9c 81       	ldd	r25, Y+4	; 0x04
     c70:	87 30       	cpi	r24, 0x07	; 7
     c72:	91 05       	cpc	r25, r1
     c74:	0c f0       	brlt	.+2      	; 0xc78 <KeyPad_4x4_adjustKeyNumber+0x82>
     c76:	3e c0       	rjmp	.+124    	; 0xcf4 <KeyPad_4x4_adjustKeyNumber+0xfe>
     c78:	37 c0       	rjmp	.+110    	; 0xce8 <KeyPad_4x4_adjustKeyNumber+0xf2>
     c7a:	2b 81       	ldd	r18, Y+3	; 0x03
     c7c:	3c 81       	ldd	r19, Y+4	; 0x04
     c7e:	2c 30       	cpi	r18, 0x0C	; 12
     c80:	31 05       	cpc	r19, r1
     c82:	09 f4       	brne	.+2      	; 0xc86 <KeyPad_4x4_adjustKeyNumber+0x90>
     c84:	46 c0       	rjmp	.+140    	; 0xd12 <KeyPad_4x4_adjustKeyNumber+0x11c>
     c86:	8b 81       	ldd	r24, Y+3	; 0x03
     c88:	9c 81       	ldd	r25, Y+4	; 0x04
     c8a:	8d 30       	cpi	r24, 0x0D	; 13
     c8c:	91 05       	cpc	r25, r1
     c8e:	5c f4       	brge	.+22     	; 0xca6 <KeyPad_4x4_adjustKeyNumber+0xb0>
     c90:	2b 81       	ldd	r18, Y+3	; 0x03
     c92:	3c 81       	ldd	r19, Y+4	; 0x04
     c94:	2a 30       	cpi	r18, 0x0A	; 10
     c96:	31 05       	cpc	r19, r1
     c98:	b1 f1       	breq	.+108    	; 0xd06 <KeyPad_4x4_adjustKeyNumber+0x110>
     c9a:	8b 81       	ldd	r24, Y+3	; 0x03
     c9c:	9c 81       	ldd	r25, Y+4	; 0x04
     c9e:	8b 30       	cpi	r24, 0x0B	; 11
     ca0:	91 05       	cpc	r25, r1
     ca2:	a4 f5       	brge	.+104    	; 0xd0c <KeyPad_4x4_adjustKeyNumber+0x116>
     ca4:	2d c0       	rjmp	.+90     	; 0xd00 <KeyPad_4x4_adjustKeyNumber+0x10a>
     ca6:	2b 81       	ldd	r18, Y+3	; 0x03
     ca8:	3c 81       	ldd	r19, Y+4	; 0x04
     caa:	2e 30       	cpi	r18, 0x0E	; 14
     cac:	31 05       	cpc	r19, r1
     cae:	b9 f1       	breq	.+110    	; 0xd1e <KeyPad_4x4_adjustKeyNumber+0x128>
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	8e 30       	cpi	r24, 0x0E	; 14
     cb6:	91 05       	cpc	r25, r1
     cb8:	7c f1       	brlt	.+94     	; 0xd18 <KeyPad_4x4_adjustKeyNumber+0x122>
     cba:	2b 81       	ldd	r18, Y+3	; 0x03
     cbc:	3c 81       	ldd	r19, Y+4	; 0x04
     cbe:	2f 30       	cpi	r18, 0x0F	; 15
     cc0:	31 05       	cpc	r19, r1
     cc2:	79 f1       	breq	.+94     	; 0xd22 <KeyPad_4x4_adjustKeyNumber+0x12c>
     cc4:	8b 81       	ldd	r24, Y+3	; 0x03
     cc6:	9c 81       	ldd	r25, Y+4	; 0x04
     cc8:	80 31       	cpi	r24, 0x10	; 16
     cca:	91 05       	cpc	r25, r1
     ccc:	69 f1       	breq	.+90     	; 0xd28 <KeyPad_4x4_adjustKeyNumber+0x132>
     cce:	2f c0       	rjmp	.+94     	; 0xd2e <KeyPad_4x4_adjustKeyNumber+0x138>
	{
		case 1: return 7;
     cd0:	97 e0       	ldi	r25, 0x07	; 7
     cd2:	9a 83       	std	Y+2, r25	; 0x02
     cd4:	2e c0       	rjmp	.+92     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 2: return 8;
     cd6:	28 e0       	ldi	r18, 0x08	; 8
     cd8:	2a 83       	std	Y+2, r18	; 0x02
     cda:	2b c0       	rjmp	.+86     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 3: return 9;
     cdc:	39 e0       	ldi	r19, 0x09	; 9
     cde:	3a 83       	std	Y+2, r19	; 0x02
     ce0:	28 c0       	rjmp	.+80     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 4: return '%'; // ASCII Code of %
     ce2:	85 e2       	ldi	r24, 0x25	; 37
     ce4:	8a 83       	std	Y+2, r24	; 0x02
     ce6:	25 c0       	rjmp	.+74     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 5: return 4;
     ce8:	94 e0       	ldi	r25, 0x04	; 4
     cea:	9a 83       	std	Y+2, r25	; 0x02
     cec:	22 c0       	rjmp	.+68     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 6: return 5;
     cee:	25 e0       	ldi	r18, 0x05	; 5
     cf0:	2a 83       	std	Y+2, r18	; 0x02
     cf2:	1f c0       	rjmp	.+62     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 7: return 6;
     cf4:	36 e0       	ldi	r19, 0x06	; 6
     cf6:	3a 83       	std	Y+2, r19	; 0x02
     cf8:	1c c0       	rjmp	.+56     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 8: return '*'; /* ASCII Code of '*' */
     cfa:	8a e2       	ldi	r24, 0x2A	; 42
     cfc:	8a 83       	std	Y+2, r24	; 0x02
     cfe:	19 c0       	rjmp	.+50     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 9: return 1;
     d00:	91 e0       	ldi	r25, 0x01	; 1
     d02:	9a 83       	std	Y+2, r25	; 0x02
     d04:	16 c0       	rjmp	.+44     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 10: return 2;
     d06:	22 e0       	ldi	r18, 0x02	; 2
     d08:	2a 83       	std	Y+2, r18	; 0x02
     d0a:	13 c0       	rjmp	.+38     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 11: return 3;
     d0c:	33 e0       	ldi	r19, 0x03	; 3
     d0e:	3a 83       	std	Y+2, r19	; 0x02
     d10:	10 c0       	rjmp	.+32     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 12: return '-'; /* ASCII Code of '-' */
     d12:	8d e2       	ldi	r24, 0x2D	; 45
     d14:	8a 83       	std	Y+2, r24	; 0x02
     d16:	0d c0       	rjmp	.+26     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 13: return 13;  /* ASCII of Enter */
     d18:	9d e0       	ldi	r25, 0x0D	; 13
     d1a:	9a 83       	std	Y+2, r25	; 0x02
     d1c:	0a c0       	rjmp	.+20     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 14: return 0;
     d1e:	1a 82       	std	Y+2, r1	; 0x02
     d20:	08 c0       	rjmp	.+16     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 15: return '='; /* ASCII Code of '=' */
     d22:	2d e3       	ldi	r18, 0x3D	; 61
     d24:	2a 83       	std	Y+2, r18	; 0x02
     d26:	05 c0       	rjmp	.+10     	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		case 16: return '+'; /* ASCII Code of '+' */
     d28:	3b e2       	ldi	r19, 0x2B	; 43
     d2a:	3a 83       	std	Y+2, r19	; 0x02
     d2c:	02 c0       	rjmp	.+4      	; 0xd32 <KeyPad_4x4_adjustKeyNumber+0x13c>
				break;
		default: return button_number;
     d2e:	89 81       	ldd	r24, Y+1	; 0x01
     d30:	8a 83       	std	Y+2, r24	; 0x02
     d32:	8a 81       	ldd	r24, Y+2	; 0x02
	}
}
     d34:	0f 90       	pop	r0
     d36:	0f 90       	pop	r0
     d38:	0f 90       	pop	r0
     d3a:	0f 90       	pop	r0
     d3c:	cf 91       	pop	r28
     d3e:	df 91       	pop	r29
     d40:	08 95       	ret

00000d42 <LCD_init>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void LCD_init(void)
{
     d42:	df 93       	push	r29
     d44:	cf 93       	push	r28
     d46:	cd b7       	in	r28, 0x3d	; 61
     d48:	de b7       	in	r29, 0x3e	; 62
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
     d4a:	e4 e3       	ldi	r30, 0x34	; 52
     d4c:	f0 e0       	ldi	r31, 0x00	; 0
     d4e:	8f ef       	ldi	r24, 0xFF	; 255
     d50:	80 83       	st	Z, r24
	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
     d52:	a1 e3       	ldi	r26, 0x31	; 49
     d54:	b0 e0       	ldi	r27, 0x00	; 0
     d56:	e1 e3       	ldi	r30, 0x31	; 49
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	80 67       	ori	r24, 0x70	; 112
     d5e:	8c 93       	st	X, r24

	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
     d60:	88 e3       	ldi	r24, 0x38	; 56
     d62:	0e 94 bc 06 	call	0xd78	; 0xd78 <LCD_sendCommand>

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
     d66:	8c e0       	ldi	r24, 0x0C	; 12
     d68:	0e 94 bc 06 	call	0xd78	; 0xd78 <LCD_sendCommand>

	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
     d6c:	81 e0       	ldi	r24, 0x01	; 1
     d6e:	0e 94 bc 06 	call	0xd78	; 0xd78 <LCD_sendCommand>
}
     d72:	cf 91       	pop	r28
     d74:	df 91       	pop	r29
     d76:	08 95       	ret

00000d78 <LCD_sendCommand>:

void LCD_sendCommand(uint8 command)
{
     d78:	df 93       	push	r29
     d7a:	cf 93       	push	r28
     d7c:	cd b7       	in	r28, 0x3d	; 61
     d7e:	de b7       	in	r29, 0x3e	; 62
     d80:	e9 97       	sbiw	r28, 0x39	; 57
     d82:	0f b6       	in	r0, 0x3f	; 63
     d84:	f8 94       	cli
     d86:	de bf       	out	0x3e, r29	; 62
     d88:	0f be       	out	0x3f, r0	; 63
     d8a:	cd bf       	out	0x3d, r28	; 61
     d8c:	89 af       	std	Y+57, r24	; 0x39
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
     d8e:	a2 e3       	ldi	r26, 0x32	; 50
     d90:	b0 e0       	ldi	r27, 0x00	; 0
     d92:	e2 e3       	ldi	r30, 0x32	; 50
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 81       	ld	r24, Z
     d98:	8f 7e       	andi	r24, 0xEF	; 239
     d9a:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
     d9c:	a2 e3       	ldi	r26, 0x32	; 50
     d9e:	b0 e0       	ldi	r27, 0x00	; 0
     da0:	e2 e3       	ldi	r30, 0x32	; 50
     da2:	f0 e0       	ldi	r31, 0x00	; 0
     da4:	80 81       	ld	r24, Z
     da6:	8f 7d       	andi	r24, 0xDF	; 223
     da8:	8c 93       	st	X, r24
     daa:	80 e0       	ldi	r24, 0x00	; 0
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	a0 e8       	ldi	r26, 0x80	; 128
     db0:	bf e3       	ldi	r27, 0x3F	; 63
     db2:	8d ab       	std	Y+53, r24	; 0x35
     db4:	9e ab       	std	Y+54, r25	; 0x36
     db6:	af ab       	std	Y+55, r26	; 0x37
     db8:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     dba:	6d a9       	ldd	r22, Y+53	; 0x35
     dbc:	7e a9       	ldd	r23, Y+54	; 0x36
     dbe:	8f a9       	ldd	r24, Y+55	; 0x37
     dc0:	98 ad       	ldd	r25, Y+56	; 0x38
     dc2:	20 e0       	ldi	r18, 0x00	; 0
     dc4:	30 e0       	ldi	r19, 0x00	; 0
     dc6:	4a e7       	ldi	r20, 0x7A	; 122
     dc8:	53 e4       	ldi	r21, 0x43	; 67
     dca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     dce:	dc 01       	movw	r26, r24
     dd0:	cb 01       	movw	r24, r22
     dd2:	89 ab       	std	Y+49, r24	; 0x31
     dd4:	9a ab       	std	Y+50, r25	; 0x32
     dd6:	ab ab       	std	Y+51, r26	; 0x33
     dd8:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     dda:	69 a9       	ldd	r22, Y+49	; 0x31
     ddc:	7a a9       	ldd	r23, Y+50	; 0x32
     dde:	8b a9       	ldd	r24, Y+51	; 0x33
     de0:	9c a9       	ldd	r25, Y+52	; 0x34
     de2:	20 e0       	ldi	r18, 0x00	; 0
     de4:	30 e0       	ldi	r19, 0x00	; 0
     de6:	40 e8       	ldi	r20, 0x80	; 128
     de8:	5f e3       	ldi	r21, 0x3F	; 63
     dea:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     dee:	88 23       	and	r24, r24
     df0:	2c f4       	brge	.+10     	; 0xdfc <LCD_sendCommand+0x84>
		__ticks = 1;
     df2:	81 e0       	ldi	r24, 0x01	; 1
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	98 ab       	std	Y+48, r25	; 0x30
     df8:	8f a7       	std	Y+47, r24	; 0x2f
     dfa:	3f c0       	rjmp	.+126    	; 0xe7a <LCD_sendCommand+0x102>
	else if (__tmp > 65535)
     dfc:	69 a9       	ldd	r22, Y+49	; 0x31
     dfe:	7a a9       	ldd	r23, Y+50	; 0x32
     e00:	8b a9       	ldd	r24, Y+51	; 0x33
     e02:	9c a9       	ldd	r25, Y+52	; 0x34
     e04:	20 e0       	ldi	r18, 0x00	; 0
     e06:	3f ef       	ldi	r19, 0xFF	; 255
     e08:	4f e7       	ldi	r20, 0x7F	; 127
     e0a:	57 e4       	ldi	r21, 0x47	; 71
     e0c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     e10:	18 16       	cp	r1, r24
     e12:	4c f5       	brge	.+82     	; 0xe66 <LCD_sendCommand+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e14:	6d a9       	ldd	r22, Y+53	; 0x35
     e16:	7e a9       	ldd	r23, Y+54	; 0x36
     e18:	8f a9       	ldd	r24, Y+55	; 0x37
     e1a:	98 ad       	ldd	r25, Y+56	; 0x38
     e1c:	20 e0       	ldi	r18, 0x00	; 0
     e1e:	30 e0       	ldi	r19, 0x00	; 0
     e20:	40 e2       	ldi	r20, 0x20	; 32
     e22:	51 e4       	ldi	r21, 0x41	; 65
     e24:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e28:	dc 01       	movw	r26, r24
     e2a:	cb 01       	movw	r24, r22
     e2c:	bc 01       	movw	r22, r24
     e2e:	cd 01       	movw	r24, r26
     e30:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e34:	dc 01       	movw	r26, r24
     e36:	cb 01       	movw	r24, r22
     e38:	98 ab       	std	Y+48, r25	; 0x30
     e3a:	8f a7       	std	Y+47, r24	; 0x2f
     e3c:	0f c0       	rjmp	.+30     	; 0xe5c <LCD_sendCommand+0xe4>
     e3e:	89 e1       	ldi	r24, 0x19	; 25
     e40:	90 e0       	ldi	r25, 0x00	; 0
     e42:	9e a7       	std	Y+46, r25	; 0x2e
     e44:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     e46:	8d a5       	ldd	r24, Y+45	; 0x2d
     e48:	9e a5       	ldd	r25, Y+46	; 0x2e
     e4a:	01 97       	sbiw	r24, 0x01	; 1
     e4c:	f1 f7       	brne	.-4      	; 0xe4a <LCD_sendCommand+0xd2>
     e4e:	9e a7       	std	Y+46, r25	; 0x2e
     e50:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e52:	8f a5       	ldd	r24, Y+47	; 0x2f
     e54:	98 a9       	ldd	r25, Y+48	; 0x30
     e56:	01 97       	sbiw	r24, 0x01	; 1
     e58:	98 ab       	std	Y+48, r25	; 0x30
     e5a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e5c:	8f a5       	ldd	r24, Y+47	; 0x2f
     e5e:	98 a9       	ldd	r25, Y+48	; 0x30
     e60:	00 97       	sbiw	r24, 0x00	; 0
     e62:	69 f7       	brne	.-38     	; 0xe3e <LCD_sendCommand+0xc6>
     e64:	14 c0       	rjmp	.+40     	; 0xe8e <LCD_sendCommand+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e66:	69 a9       	ldd	r22, Y+49	; 0x31
     e68:	7a a9       	ldd	r23, Y+50	; 0x32
     e6a:	8b a9       	ldd	r24, Y+51	; 0x33
     e6c:	9c a9       	ldd	r25, Y+52	; 0x34
     e6e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e72:	dc 01       	movw	r26, r24
     e74:	cb 01       	movw	r24, r22
     e76:	98 ab       	std	Y+48, r25	; 0x30
     e78:	8f a7       	std	Y+47, r24	; 0x2f
     e7a:	8f a5       	ldd	r24, Y+47	; 0x2f
     e7c:	98 a9       	ldd	r25, Y+48	; 0x30
     e7e:	9c a7       	std	Y+44, r25	; 0x2c
     e80:	8b a7       	std	Y+43, r24	; 0x2b
     e82:	8b a5       	ldd	r24, Y+43	; 0x2b
     e84:	9c a5       	ldd	r25, Y+44	; 0x2c
     e86:	01 97       	sbiw	r24, 0x01	; 1
     e88:	f1 f7       	brne	.-4      	; 0xe86 <LCD_sendCommand+0x10e>
     e8a:	9c a7       	std	Y+44, r25	; 0x2c
     e8c:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
     e8e:	a2 e3       	ldi	r26, 0x32	; 50
     e90:	b0 e0       	ldi	r27, 0x00	; 0
     e92:	e2 e3       	ldi	r30, 0x32	; 50
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	80 81       	ld	r24, Z
     e98:	80 64       	ori	r24, 0x40	; 64
     e9a:	8c 93       	st	X, r24
     e9c:	80 e0       	ldi	r24, 0x00	; 0
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	a0 e8       	ldi	r26, 0x80	; 128
     ea2:	bf e3       	ldi	r27, 0x3F	; 63
     ea4:	8f a3       	std	Y+39, r24	; 0x27
     ea6:	98 a7       	std	Y+40, r25	; 0x28
     ea8:	a9 a7       	std	Y+41, r26	; 0x29
     eaa:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     eac:	6f a1       	ldd	r22, Y+39	; 0x27
     eae:	78 a5       	ldd	r23, Y+40	; 0x28
     eb0:	89 a5       	ldd	r24, Y+41	; 0x29
     eb2:	9a a5       	ldd	r25, Y+42	; 0x2a
     eb4:	20 e0       	ldi	r18, 0x00	; 0
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	4a e7       	ldi	r20, 0x7A	; 122
     eba:	53 e4       	ldi	r21, 0x43	; 67
     ebc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ec0:	dc 01       	movw	r26, r24
     ec2:	cb 01       	movw	r24, r22
     ec4:	8b a3       	std	Y+35, r24	; 0x23
     ec6:	9c a3       	std	Y+36, r25	; 0x24
     ec8:	ad a3       	std	Y+37, r26	; 0x25
     eca:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     ecc:	6b a1       	ldd	r22, Y+35	; 0x23
     ece:	7c a1       	ldd	r23, Y+36	; 0x24
     ed0:	8d a1       	ldd	r24, Y+37	; 0x25
     ed2:	9e a1       	ldd	r25, Y+38	; 0x26
     ed4:	20 e0       	ldi	r18, 0x00	; 0
     ed6:	30 e0       	ldi	r19, 0x00	; 0
     ed8:	40 e8       	ldi	r20, 0x80	; 128
     eda:	5f e3       	ldi	r21, 0x3F	; 63
     edc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     ee0:	88 23       	and	r24, r24
     ee2:	2c f4       	brge	.+10     	; 0xeee <LCD_sendCommand+0x176>
		__ticks = 1;
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	9a a3       	std	Y+34, r25	; 0x22
     eea:	89 a3       	std	Y+33, r24	; 0x21
     eec:	3f c0       	rjmp	.+126    	; 0xf6c <LCD_sendCommand+0x1f4>
	else if (__tmp > 65535)
     eee:	6b a1       	ldd	r22, Y+35	; 0x23
     ef0:	7c a1       	ldd	r23, Y+36	; 0x24
     ef2:	8d a1       	ldd	r24, Y+37	; 0x25
     ef4:	9e a1       	ldd	r25, Y+38	; 0x26
     ef6:	20 e0       	ldi	r18, 0x00	; 0
     ef8:	3f ef       	ldi	r19, 0xFF	; 255
     efa:	4f e7       	ldi	r20, 0x7F	; 127
     efc:	57 e4       	ldi	r21, 0x47	; 71
     efe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     f02:	18 16       	cp	r1, r24
     f04:	4c f5       	brge	.+82     	; 0xf58 <LCD_sendCommand+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f06:	6f a1       	ldd	r22, Y+39	; 0x27
     f08:	78 a5       	ldd	r23, Y+40	; 0x28
     f0a:	89 a5       	ldd	r24, Y+41	; 0x29
     f0c:	9a a5       	ldd	r25, Y+42	; 0x2a
     f0e:	20 e0       	ldi	r18, 0x00	; 0
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	40 e2       	ldi	r20, 0x20	; 32
     f14:	51 e4       	ldi	r21, 0x41	; 65
     f16:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f1a:	dc 01       	movw	r26, r24
     f1c:	cb 01       	movw	r24, r22
     f1e:	bc 01       	movw	r22, r24
     f20:	cd 01       	movw	r24, r26
     f22:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f26:	dc 01       	movw	r26, r24
     f28:	cb 01       	movw	r24, r22
     f2a:	9a a3       	std	Y+34, r25	; 0x22
     f2c:	89 a3       	std	Y+33, r24	; 0x21
     f2e:	0f c0       	rjmp	.+30     	; 0xf4e <LCD_sendCommand+0x1d6>
     f30:	89 e1       	ldi	r24, 0x19	; 25
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	98 a3       	std	Y+32, r25	; 0x20
     f36:	8f 8f       	std	Y+31, r24	; 0x1f
     f38:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f3a:	98 a1       	ldd	r25, Y+32	; 0x20
     f3c:	01 97       	sbiw	r24, 0x01	; 1
     f3e:	f1 f7       	brne	.-4      	; 0xf3c <LCD_sendCommand+0x1c4>
     f40:	98 a3       	std	Y+32, r25	; 0x20
     f42:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f44:	89 a1       	ldd	r24, Y+33	; 0x21
     f46:	9a a1       	ldd	r25, Y+34	; 0x22
     f48:	01 97       	sbiw	r24, 0x01	; 1
     f4a:	9a a3       	std	Y+34, r25	; 0x22
     f4c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f4e:	89 a1       	ldd	r24, Y+33	; 0x21
     f50:	9a a1       	ldd	r25, Y+34	; 0x22
     f52:	00 97       	sbiw	r24, 0x00	; 0
     f54:	69 f7       	brne	.-38     	; 0xf30 <LCD_sendCommand+0x1b8>
     f56:	14 c0       	rjmp	.+40     	; 0xf80 <LCD_sendCommand+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f58:	6b a1       	ldd	r22, Y+35	; 0x23
     f5a:	7c a1       	ldd	r23, Y+36	; 0x24
     f5c:	8d a1       	ldd	r24, Y+37	; 0x25
     f5e:	9e a1       	ldd	r25, Y+38	; 0x26
     f60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f64:	dc 01       	movw	r26, r24
     f66:	cb 01       	movw	r24, r22
     f68:	9a a3       	std	Y+34, r25	; 0x22
     f6a:	89 a3       	std	Y+33, r24	; 0x21
     f6c:	89 a1       	ldd	r24, Y+33	; 0x21
     f6e:	9a a1       	ldd	r25, Y+34	; 0x22
     f70:	9e 8f       	std	Y+30, r25	; 0x1e
     f72:	8d 8f       	std	Y+29, r24	; 0x1d
     f74:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f76:	9e 8d       	ldd	r25, Y+30	; 0x1e
     f78:	01 97       	sbiw	r24, 0x01	; 1
     f7a:	f1 f7       	brne	.-4      	; 0xf78 <LCD_sendCommand+0x200>
     f7c:	9e 8f       	std	Y+30, r25	; 0x1e
     f7e:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
     f80:	e5 e3       	ldi	r30, 0x35	; 53
     f82:	f0 e0       	ldi	r31, 0x00	; 0
     f84:	89 ad       	ldd	r24, Y+57	; 0x39
     f86:	80 83       	st	Z, r24
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	a0 e8       	ldi	r26, 0x80	; 128
     f8e:	bf e3       	ldi	r27, 0x3F	; 63
     f90:	89 8f       	std	Y+25, r24	; 0x19
     f92:	9a 8f       	std	Y+26, r25	; 0x1a
     f94:	ab 8f       	std	Y+27, r26	; 0x1b
     f96:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     f98:	69 8d       	ldd	r22, Y+25	; 0x19
     f9a:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f9c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f9e:	9c 8d       	ldd	r25, Y+28	; 0x1c
     fa0:	20 e0       	ldi	r18, 0x00	; 0
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	4a e7       	ldi	r20, 0x7A	; 122
     fa6:	53 e4       	ldi	r21, 0x43	; 67
     fa8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fac:	dc 01       	movw	r26, r24
     fae:	cb 01       	movw	r24, r22
     fb0:	8d 8b       	std	Y+21, r24	; 0x15
     fb2:	9e 8b       	std	Y+22, r25	; 0x16
     fb4:	af 8b       	std	Y+23, r26	; 0x17
     fb6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     fb8:	6d 89       	ldd	r22, Y+21	; 0x15
     fba:	7e 89       	ldd	r23, Y+22	; 0x16
     fbc:	8f 89       	ldd	r24, Y+23	; 0x17
     fbe:	98 8d       	ldd	r25, Y+24	; 0x18
     fc0:	20 e0       	ldi	r18, 0x00	; 0
     fc2:	30 e0       	ldi	r19, 0x00	; 0
     fc4:	40 e8       	ldi	r20, 0x80	; 128
     fc6:	5f e3       	ldi	r21, 0x3F	; 63
     fc8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     fcc:	88 23       	and	r24, r24
     fce:	2c f4       	brge	.+10     	; 0xfda <LCD_sendCommand+0x262>
		__ticks = 1;
     fd0:	81 e0       	ldi	r24, 0x01	; 1
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	9c 8b       	std	Y+20, r25	; 0x14
     fd6:	8b 8b       	std	Y+19, r24	; 0x13
     fd8:	3f c0       	rjmp	.+126    	; 0x1058 <LCD_sendCommand+0x2e0>
	else if (__tmp > 65535)
     fda:	6d 89       	ldd	r22, Y+21	; 0x15
     fdc:	7e 89       	ldd	r23, Y+22	; 0x16
     fde:	8f 89       	ldd	r24, Y+23	; 0x17
     fe0:	98 8d       	ldd	r25, Y+24	; 0x18
     fe2:	20 e0       	ldi	r18, 0x00	; 0
     fe4:	3f ef       	ldi	r19, 0xFF	; 255
     fe6:	4f e7       	ldi	r20, 0x7F	; 127
     fe8:	57 e4       	ldi	r21, 0x47	; 71
     fea:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     fee:	18 16       	cp	r1, r24
     ff0:	4c f5       	brge	.+82     	; 0x1044 <LCD_sendCommand+0x2cc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ff2:	69 8d       	ldd	r22, Y+25	; 0x19
     ff4:	7a 8d       	ldd	r23, Y+26	; 0x1a
     ff6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ff8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	40 e2       	ldi	r20, 0x20	; 32
    1000:	51 e4       	ldi	r21, 0x41	; 65
    1002:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1006:	dc 01       	movw	r26, r24
    1008:	cb 01       	movw	r24, r22
    100a:	bc 01       	movw	r22, r24
    100c:	cd 01       	movw	r24, r26
    100e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1012:	dc 01       	movw	r26, r24
    1014:	cb 01       	movw	r24, r22
    1016:	9c 8b       	std	Y+20, r25	; 0x14
    1018:	8b 8b       	std	Y+19, r24	; 0x13
    101a:	0f c0       	rjmp	.+30     	; 0x103a <LCD_sendCommand+0x2c2>
    101c:	89 e1       	ldi	r24, 0x19	; 25
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	9a 8b       	std	Y+18, r25	; 0x12
    1022:	89 8b       	std	Y+17, r24	; 0x11
    1024:	89 89       	ldd	r24, Y+17	; 0x11
    1026:	9a 89       	ldd	r25, Y+18	; 0x12
    1028:	01 97       	sbiw	r24, 0x01	; 1
    102a:	f1 f7       	brne	.-4      	; 0x1028 <LCD_sendCommand+0x2b0>
    102c:	9a 8b       	std	Y+18, r25	; 0x12
    102e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1030:	8b 89       	ldd	r24, Y+19	; 0x13
    1032:	9c 89       	ldd	r25, Y+20	; 0x14
    1034:	01 97       	sbiw	r24, 0x01	; 1
    1036:	9c 8b       	std	Y+20, r25	; 0x14
    1038:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    103a:	8b 89       	ldd	r24, Y+19	; 0x13
    103c:	9c 89       	ldd	r25, Y+20	; 0x14
    103e:	00 97       	sbiw	r24, 0x00	; 0
    1040:	69 f7       	brne	.-38     	; 0x101c <LCD_sendCommand+0x2a4>
    1042:	14 c0       	rjmp	.+40     	; 0x106c <LCD_sendCommand+0x2f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1044:	6d 89       	ldd	r22, Y+21	; 0x15
    1046:	7e 89       	ldd	r23, Y+22	; 0x16
    1048:	8f 89       	ldd	r24, Y+23	; 0x17
    104a:	98 8d       	ldd	r25, Y+24	; 0x18
    104c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1050:	dc 01       	movw	r26, r24
    1052:	cb 01       	movw	r24, r22
    1054:	9c 8b       	std	Y+20, r25	; 0x14
    1056:	8b 8b       	std	Y+19, r24	; 0x13
    1058:	8b 89       	ldd	r24, Y+19	; 0x13
    105a:	9c 89       	ldd	r25, Y+20	; 0x14
    105c:	98 8b       	std	Y+16, r25	; 0x10
    105e:	8f 87       	std	Y+15, r24	; 0x0f
    1060:	8f 85       	ldd	r24, Y+15	; 0x0f
    1062:	98 89       	ldd	r25, Y+16	; 0x10
    1064:	01 97       	sbiw	r24, 0x01	; 1
    1066:	f1 f7       	brne	.-4      	; 0x1064 <LCD_sendCommand+0x2ec>
    1068:	98 8b       	std	Y+16, r25	; 0x10
    106a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    106c:	a2 e3       	ldi	r26, 0x32	; 50
    106e:	b0 e0       	ldi	r27, 0x00	; 0
    1070:	e2 e3       	ldi	r30, 0x32	; 50
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    1074:	80 81       	ld	r24, Z
    1076:	8f 7b       	andi	r24, 0xBF	; 191
    1078:	8c 93       	st	X, r24
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	a0 e8       	ldi	r26, 0x80	; 128
    1080:	bf e3       	ldi	r27, 0x3F	; 63
    1082:	8b 87       	std	Y+11, r24	; 0x0b
    1084:	9c 87       	std	Y+12, r25	; 0x0c
    1086:	ad 87       	std	Y+13, r26	; 0x0d
    1088:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    108a:	6b 85       	ldd	r22, Y+11	; 0x0b
    108c:	7c 85       	ldd	r23, Y+12	; 0x0c
    108e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1090:	9e 85       	ldd	r25, Y+14	; 0x0e
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	4a e7       	ldi	r20, 0x7A	; 122
    1098:	53 e4       	ldi	r21, 0x43	; 67
    109a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    109e:	dc 01       	movw	r26, r24
    10a0:	cb 01       	movw	r24, r22
    10a2:	8f 83       	std	Y+7, r24	; 0x07
    10a4:	98 87       	std	Y+8, r25	; 0x08
    10a6:	a9 87       	std	Y+9, r26	; 0x09
    10a8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    10aa:	6f 81       	ldd	r22, Y+7	; 0x07
    10ac:	78 85       	ldd	r23, Y+8	; 0x08
    10ae:	89 85       	ldd	r24, Y+9	; 0x09
    10b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    10b2:	20 e0       	ldi	r18, 0x00	; 0
    10b4:	30 e0       	ldi	r19, 0x00	; 0
    10b6:	40 e8       	ldi	r20, 0x80	; 128
    10b8:	5f e3       	ldi	r21, 0x3F	; 63
    10ba:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    10be:	88 23       	and	r24, r24
    10c0:	2c f4       	brge	.+10     	; 0x10cc <LCD_sendCommand+0x354>
		__ticks = 1;
    10c2:	81 e0       	ldi	r24, 0x01	; 1
    10c4:	90 e0       	ldi	r25, 0x00	; 0
    10c6:	9e 83       	std	Y+6, r25	; 0x06
    10c8:	8d 83       	std	Y+5, r24	; 0x05
    10ca:	3f c0       	rjmp	.+126    	; 0x114a <LCD_sendCommand+0x3d2>
	else if (__tmp > 65535)
    10cc:	6f 81       	ldd	r22, Y+7	; 0x07
    10ce:	78 85       	ldd	r23, Y+8	; 0x08
    10d0:	89 85       	ldd	r24, Y+9	; 0x09
    10d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    10d4:	20 e0       	ldi	r18, 0x00	; 0
    10d6:	3f ef       	ldi	r19, 0xFF	; 255
    10d8:	4f e7       	ldi	r20, 0x7F	; 127
    10da:	57 e4       	ldi	r21, 0x47	; 71
    10dc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    10e0:	18 16       	cp	r1, r24
    10e2:	4c f5       	brge	.+82     	; 0x1136 <LCD_sendCommand+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10e4:	6b 85       	ldd	r22, Y+11	; 0x0b
    10e6:	7c 85       	ldd	r23, Y+12	; 0x0c
    10e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    10ea:	9e 85       	ldd	r25, Y+14	; 0x0e
    10ec:	20 e0       	ldi	r18, 0x00	; 0
    10ee:	30 e0       	ldi	r19, 0x00	; 0
    10f0:	40 e2       	ldi	r20, 0x20	; 32
    10f2:	51 e4       	ldi	r21, 0x41	; 65
    10f4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10f8:	dc 01       	movw	r26, r24
    10fa:	cb 01       	movw	r24, r22
    10fc:	bc 01       	movw	r22, r24
    10fe:	cd 01       	movw	r24, r26
    1100:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1104:	dc 01       	movw	r26, r24
    1106:	cb 01       	movw	r24, r22
    1108:	9e 83       	std	Y+6, r25	; 0x06
    110a:	8d 83       	std	Y+5, r24	; 0x05
    110c:	0f c0       	rjmp	.+30     	; 0x112c <LCD_sendCommand+0x3b4>
    110e:	89 e1       	ldi	r24, 0x19	; 25
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	9c 83       	std	Y+4, r25	; 0x04
    1114:	8b 83       	std	Y+3, r24	; 0x03
    1116:	8b 81       	ldd	r24, Y+3	; 0x03
    1118:	9c 81       	ldd	r25, Y+4	; 0x04
    111a:	01 97       	sbiw	r24, 0x01	; 1
    111c:	f1 f7       	brne	.-4      	; 0x111a <LCD_sendCommand+0x3a2>
    111e:	9c 83       	std	Y+4, r25	; 0x04
    1120:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1122:	8d 81       	ldd	r24, Y+5	; 0x05
    1124:	9e 81       	ldd	r25, Y+6	; 0x06
    1126:	01 97       	sbiw	r24, 0x01	; 1
    1128:	9e 83       	std	Y+6, r25	; 0x06
    112a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    112c:	8d 81       	ldd	r24, Y+5	; 0x05
    112e:	9e 81       	ldd	r25, Y+6	; 0x06
    1130:	00 97       	sbiw	r24, 0x00	; 0
    1132:	69 f7       	brne	.-38     	; 0x110e <LCD_sendCommand+0x396>
    1134:	14 c0       	rjmp	.+40     	; 0x115e <LCD_sendCommand+0x3e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1136:	6f 81       	ldd	r22, Y+7	; 0x07
    1138:	78 85       	ldd	r23, Y+8	; 0x08
    113a:	89 85       	ldd	r24, Y+9	; 0x09
    113c:	9a 85       	ldd	r25, Y+10	; 0x0a
    113e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1142:	dc 01       	movw	r26, r24
    1144:	cb 01       	movw	r24, r22
    1146:	9e 83       	std	Y+6, r25	; 0x06
    1148:	8d 83       	std	Y+5, r24	; 0x05
    114a:	8d 81       	ldd	r24, Y+5	; 0x05
    114c:	9e 81       	ldd	r25, Y+6	; 0x06
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
    1152:	89 81       	ldd	r24, Y+1	; 0x01
    1154:	9a 81       	ldd	r25, Y+2	; 0x02
    1156:	01 97       	sbiw	r24, 0x01	; 1
    1158:	f1 f7       	brne	.-4      	; 0x1156 <LCD_sendCommand+0x3de>
    115a:	9a 83       	std	Y+2, r25	; 0x02
    115c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
}
    115e:	e9 96       	adiw	r28, 0x39	; 57
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	de bf       	out	0x3e, r29	; 62
    1166:	0f be       	out	0x3f, r0	; 63
    1168:	cd bf       	out	0x3d, r28	; 61
    116a:	cf 91       	pop	r28
    116c:	df 91       	pop	r29
    116e:	08 95       	ret

00001170 <LCD_displayCharacter>:

void LCD_displayCharacter(uint8 data)
{
    1170:	df 93       	push	r29
    1172:	cf 93       	push	r28
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
    1178:	e9 97       	sbiw	r28, 0x39	; 57
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	f8 94       	cli
    117e:	de bf       	out	0x3e, r29	; 62
    1180:	0f be       	out	0x3f, r0	; 63
    1182:	cd bf       	out	0x3d, r28	; 61
    1184:	89 af       	std	Y+57, r24	; 0x39
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1186:	a2 e3       	ldi	r26, 0x32	; 50
    1188:	b0 e0       	ldi	r27, 0x00	; 0
    118a:	e2 e3       	ldi	r30, 0x32	; 50
    118c:	f0 e0       	ldi	r31, 0x00	; 0
    118e:	80 81       	ld	r24, Z
    1190:	80 61       	ori	r24, 0x10	; 16
    1192:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1194:	a2 e3       	ldi	r26, 0x32	; 50
    1196:	b0 e0       	ldi	r27, 0x00	; 0
    1198:	e2 e3       	ldi	r30, 0x32	; 50
    119a:	f0 e0       	ldi	r31, 0x00	; 0
    119c:	80 81       	ld	r24, Z
    119e:	8f 7d       	andi	r24, 0xDF	; 223
    11a0:	8c 93       	st	X, r24
    11a2:	80 e0       	ldi	r24, 0x00	; 0
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	a0 e8       	ldi	r26, 0x80	; 128
    11a8:	bf e3       	ldi	r27, 0x3F	; 63
    11aa:	8d ab       	std	Y+53, r24	; 0x35
    11ac:	9e ab       	std	Y+54, r25	; 0x36
    11ae:	af ab       	std	Y+55, r26	; 0x37
    11b0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    11b2:	6d a9       	ldd	r22, Y+53	; 0x35
    11b4:	7e a9       	ldd	r23, Y+54	; 0x36
    11b6:	8f a9       	ldd	r24, Y+55	; 0x37
    11b8:	98 ad       	ldd	r25, Y+56	; 0x38
    11ba:	20 e0       	ldi	r18, 0x00	; 0
    11bc:	30 e0       	ldi	r19, 0x00	; 0
    11be:	4a e7       	ldi	r20, 0x7A	; 122
    11c0:	53 e4       	ldi	r21, 0x43	; 67
    11c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11c6:	dc 01       	movw	r26, r24
    11c8:	cb 01       	movw	r24, r22
    11ca:	89 ab       	std	Y+49, r24	; 0x31
    11cc:	9a ab       	std	Y+50, r25	; 0x32
    11ce:	ab ab       	std	Y+51, r26	; 0x33
    11d0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    11d2:	69 a9       	ldd	r22, Y+49	; 0x31
    11d4:	7a a9       	ldd	r23, Y+50	; 0x32
    11d6:	8b a9       	ldd	r24, Y+51	; 0x33
    11d8:	9c a9       	ldd	r25, Y+52	; 0x34
    11da:	20 e0       	ldi	r18, 0x00	; 0
    11dc:	30 e0       	ldi	r19, 0x00	; 0
    11de:	40 e8       	ldi	r20, 0x80	; 128
    11e0:	5f e3       	ldi	r21, 0x3F	; 63
    11e2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    11e6:	88 23       	and	r24, r24
    11e8:	2c f4       	brge	.+10     	; 0x11f4 <LCD_displayCharacter+0x84>
		__ticks = 1;
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	98 ab       	std	Y+48, r25	; 0x30
    11f0:	8f a7       	std	Y+47, r24	; 0x2f
    11f2:	3f c0       	rjmp	.+126    	; 0x1272 <LCD_displayCharacter+0x102>
	else if (__tmp > 65535)
    11f4:	69 a9       	ldd	r22, Y+49	; 0x31
    11f6:	7a a9       	ldd	r23, Y+50	; 0x32
    11f8:	8b a9       	ldd	r24, Y+51	; 0x33
    11fa:	9c a9       	ldd	r25, Y+52	; 0x34
    11fc:	20 e0       	ldi	r18, 0x00	; 0
    11fe:	3f ef       	ldi	r19, 0xFF	; 255
    1200:	4f e7       	ldi	r20, 0x7F	; 127
    1202:	57 e4       	ldi	r21, 0x47	; 71
    1204:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1208:	18 16       	cp	r1, r24
    120a:	4c f5       	brge	.+82     	; 0x125e <LCD_displayCharacter+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    120c:	6d a9       	ldd	r22, Y+53	; 0x35
    120e:	7e a9       	ldd	r23, Y+54	; 0x36
    1210:	8f a9       	ldd	r24, Y+55	; 0x37
    1212:	98 ad       	ldd	r25, Y+56	; 0x38
    1214:	20 e0       	ldi	r18, 0x00	; 0
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	40 e2       	ldi	r20, 0x20	; 32
    121a:	51 e4       	ldi	r21, 0x41	; 65
    121c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1220:	dc 01       	movw	r26, r24
    1222:	cb 01       	movw	r24, r22
    1224:	bc 01       	movw	r22, r24
    1226:	cd 01       	movw	r24, r26
    1228:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    122c:	dc 01       	movw	r26, r24
    122e:	cb 01       	movw	r24, r22
    1230:	98 ab       	std	Y+48, r25	; 0x30
    1232:	8f a7       	std	Y+47, r24	; 0x2f
    1234:	0f c0       	rjmp	.+30     	; 0x1254 <LCD_displayCharacter+0xe4>
    1236:	89 e1       	ldi	r24, 0x19	; 25
    1238:	90 e0       	ldi	r25, 0x00	; 0
    123a:	9e a7       	std	Y+46, r25	; 0x2e
    123c:	8d a7       	std	Y+45, r24	; 0x2d
    123e:	8d a5       	ldd	r24, Y+45	; 0x2d
    1240:	9e a5       	ldd	r25, Y+46	; 0x2e
    1242:	01 97       	sbiw	r24, 0x01	; 1
    1244:	f1 f7       	brne	.-4      	; 0x1242 <LCD_displayCharacter+0xd2>
    1246:	9e a7       	std	Y+46, r25	; 0x2e
    1248:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    124a:	8f a5       	ldd	r24, Y+47	; 0x2f
    124c:	98 a9       	ldd	r25, Y+48	; 0x30
    124e:	01 97       	sbiw	r24, 0x01	; 1
    1250:	98 ab       	std	Y+48, r25	; 0x30
    1252:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1254:	8f a5       	ldd	r24, Y+47	; 0x2f
    1256:	98 a9       	ldd	r25, Y+48	; 0x30
    1258:	00 97       	sbiw	r24, 0x00	; 0
    125a:	69 f7       	brne	.-38     	; 0x1236 <LCD_displayCharacter+0xc6>
    125c:	14 c0       	rjmp	.+40     	; 0x1286 <LCD_displayCharacter+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    125e:	69 a9       	ldd	r22, Y+49	; 0x31
    1260:	7a a9       	ldd	r23, Y+50	; 0x32
    1262:	8b a9       	ldd	r24, Y+51	; 0x33
    1264:	9c a9       	ldd	r25, Y+52	; 0x34
    1266:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    126a:	dc 01       	movw	r26, r24
    126c:	cb 01       	movw	r24, r22
    126e:	98 ab       	std	Y+48, r25	; 0x30
    1270:	8f a7       	std	Y+47, r24	; 0x2f
    1272:	8f a5       	ldd	r24, Y+47	; 0x2f
    1274:	98 a9       	ldd	r25, Y+48	; 0x30
    1276:	9c a7       	std	Y+44, r25	; 0x2c
    1278:	8b a7       	std	Y+43, r24	; 0x2b
    127a:	8b a5       	ldd	r24, Y+43	; 0x2b
    127c:	9c a5       	ldd	r25, Y+44	; 0x2c
    127e:	01 97       	sbiw	r24, 0x01	; 1
    1280:	f1 f7       	brne	.-4      	; 0x127e <LCD_displayCharacter+0x10e>
    1282:	9c a7       	std	Y+44, r25	; 0x2c
    1284:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1286:	a2 e3       	ldi	r26, 0x32	; 50
    1288:	b0 e0       	ldi	r27, 0x00	; 0
    128a:	e2 e3       	ldi	r30, 0x32	; 50
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	80 81       	ld	r24, Z
    1290:	80 64       	ori	r24, 0x40	; 64
    1292:	8c 93       	st	X, r24
    1294:	80 e0       	ldi	r24, 0x00	; 0
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	a0 e8       	ldi	r26, 0x80	; 128
    129a:	bf e3       	ldi	r27, 0x3F	; 63
    129c:	8f a3       	std	Y+39, r24	; 0x27
    129e:	98 a7       	std	Y+40, r25	; 0x28
    12a0:	a9 a7       	std	Y+41, r26	; 0x29
    12a2:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    12a4:	6f a1       	ldd	r22, Y+39	; 0x27
    12a6:	78 a5       	ldd	r23, Y+40	; 0x28
    12a8:	89 a5       	ldd	r24, Y+41	; 0x29
    12aa:	9a a5       	ldd	r25, Y+42	; 0x2a
    12ac:	20 e0       	ldi	r18, 0x00	; 0
    12ae:	30 e0       	ldi	r19, 0x00	; 0
    12b0:	4a e7       	ldi	r20, 0x7A	; 122
    12b2:	53 e4       	ldi	r21, 0x43	; 67
    12b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12b8:	dc 01       	movw	r26, r24
    12ba:	cb 01       	movw	r24, r22
    12bc:	8b a3       	std	Y+35, r24	; 0x23
    12be:	9c a3       	std	Y+36, r25	; 0x24
    12c0:	ad a3       	std	Y+37, r26	; 0x25
    12c2:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    12c4:	6b a1       	ldd	r22, Y+35	; 0x23
    12c6:	7c a1       	ldd	r23, Y+36	; 0x24
    12c8:	8d a1       	ldd	r24, Y+37	; 0x25
    12ca:	9e a1       	ldd	r25, Y+38	; 0x26
    12cc:	20 e0       	ldi	r18, 0x00	; 0
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	40 e8       	ldi	r20, 0x80	; 128
    12d2:	5f e3       	ldi	r21, 0x3F	; 63
    12d4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    12d8:	88 23       	and	r24, r24
    12da:	2c f4       	brge	.+10     	; 0x12e6 <LCD_displayCharacter+0x176>
		__ticks = 1;
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	9a a3       	std	Y+34, r25	; 0x22
    12e2:	89 a3       	std	Y+33, r24	; 0x21
    12e4:	3f c0       	rjmp	.+126    	; 0x1364 <LCD_displayCharacter+0x1f4>
	else if (__tmp > 65535)
    12e6:	6b a1       	ldd	r22, Y+35	; 0x23
    12e8:	7c a1       	ldd	r23, Y+36	; 0x24
    12ea:	8d a1       	ldd	r24, Y+37	; 0x25
    12ec:	9e a1       	ldd	r25, Y+38	; 0x26
    12ee:	20 e0       	ldi	r18, 0x00	; 0
    12f0:	3f ef       	ldi	r19, 0xFF	; 255
    12f2:	4f e7       	ldi	r20, 0x7F	; 127
    12f4:	57 e4       	ldi	r21, 0x47	; 71
    12f6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    12fa:	18 16       	cp	r1, r24
    12fc:	4c f5       	brge	.+82     	; 0x1350 <LCD_displayCharacter+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    12fe:	6f a1       	ldd	r22, Y+39	; 0x27
    1300:	78 a5       	ldd	r23, Y+40	; 0x28
    1302:	89 a5       	ldd	r24, Y+41	; 0x29
    1304:	9a a5       	ldd	r25, Y+42	; 0x2a
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	40 e2       	ldi	r20, 0x20	; 32
    130c:	51 e4       	ldi	r21, 0x41	; 65
    130e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1312:	dc 01       	movw	r26, r24
    1314:	cb 01       	movw	r24, r22
    1316:	bc 01       	movw	r22, r24
    1318:	cd 01       	movw	r24, r26
    131a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    131e:	dc 01       	movw	r26, r24
    1320:	cb 01       	movw	r24, r22
    1322:	9a a3       	std	Y+34, r25	; 0x22
    1324:	89 a3       	std	Y+33, r24	; 0x21
    1326:	0f c0       	rjmp	.+30     	; 0x1346 <LCD_displayCharacter+0x1d6>
    1328:	89 e1       	ldi	r24, 0x19	; 25
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	98 a3       	std	Y+32, r25	; 0x20
    132e:	8f 8f       	std	Y+31, r24	; 0x1f
    1330:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1332:	98 a1       	ldd	r25, Y+32	; 0x20
    1334:	01 97       	sbiw	r24, 0x01	; 1
    1336:	f1 f7       	brne	.-4      	; 0x1334 <LCD_displayCharacter+0x1c4>
    1338:	98 a3       	std	Y+32, r25	; 0x20
    133a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    133c:	89 a1       	ldd	r24, Y+33	; 0x21
    133e:	9a a1       	ldd	r25, Y+34	; 0x22
    1340:	01 97       	sbiw	r24, 0x01	; 1
    1342:	9a a3       	std	Y+34, r25	; 0x22
    1344:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1346:	89 a1       	ldd	r24, Y+33	; 0x21
    1348:	9a a1       	ldd	r25, Y+34	; 0x22
    134a:	00 97       	sbiw	r24, 0x00	; 0
    134c:	69 f7       	brne	.-38     	; 0x1328 <LCD_displayCharacter+0x1b8>
    134e:	14 c0       	rjmp	.+40     	; 0x1378 <LCD_displayCharacter+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1350:	6b a1       	ldd	r22, Y+35	; 0x23
    1352:	7c a1       	ldd	r23, Y+36	; 0x24
    1354:	8d a1       	ldd	r24, Y+37	; 0x25
    1356:	9e a1       	ldd	r25, Y+38	; 0x26
    1358:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    135c:	dc 01       	movw	r26, r24
    135e:	cb 01       	movw	r24, r22
    1360:	9a a3       	std	Y+34, r25	; 0x22
    1362:	89 a3       	std	Y+33, r24	; 0x21
    1364:	89 a1       	ldd	r24, Y+33	; 0x21
    1366:	9a a1       	ldd	r25, Y+34	; 0x22
    1368:	9e 8f       	std	Y+30, r25	; 0x1e
    136a:	8d 8f       	std	Y+29, r24	; 0x1d
    136c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    136e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1370:	01 97       	sbiw	r24, 0x01	; 1
    1372:	f1 f7       	brne	.-4      	; 0x1370 <LCD_displayCharacter+0x200>
    1374:	9e 8f       	std	Y+30, r25	; 0x1e
    1376:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */
	LCD_DATA_PORT = data; /* out the required data char to the data bus D0 --> D7 */
    1378:	e5 e3       	ldi	r30, 0x35	; 53
    137a:	f0 e0       	ldi	r31, 0x00	; 0
    137c:	89 ad       	ldd	r24, Y+57	; 0x39
    137e:	80 83       	st	Z, r24
    1380:	80 e0       	ldi	r24, 0x00	; 0
    1382:	90 e0       	ldi	r25, 0x00	; 0
    1384:	a0 e8       	ldi	r26, 0x80	; 128
    1386:	bf e3       	ldi	r27, 0x3F	; 63
    1388:	89 8f       	std	Y+25, r24	; 0x19
    138a:	9a 8f       	std	Y+26, r25	; 0x1a
    138c:	ab 8f       	std	Y+27, r26	; 0x1b
    138e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1390:	69 8d       	ldd	r22, Y+25	; 0x19
    1392:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1394:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1396:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1398:	20 e0       	ldi	r18, 0x00	; 0
    139a:	30 e0       	ldi	r19, 0x00	; 0
    139c:	4a e7       	ldi	r20, 0x7A	; 122
    139e:	53 e4       	ldi	r21, 0x43	; 67
    13a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13a4:	dc 01       	movw	r26, r24
    13a6:	cb 01       	movw	r24, r22
    13a8:	8d 8b       	std	Y+21, r24	; 0x15
    13aa:	9e 8b       	std	Y+22, r25	; 0x16
    13ac:	af 8b       	std	Y+23, r26	; 0x17
    13ae:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    13b0:	6d 89       	ldd	r22, Y+21	; 0x15
    13b2:	7e 89       	ldd	r23, Y+22	; 0x16
    13b4:	8f 89       	ldd	r24, Y+23	; 0x17
    13b6:	98 8d       	ldd	r25, Y+24	; 0x18
    13b8:	20 e0       	ldi	r18, 0x00	; 0
    13ba:	30 e0       	ldi	r19, 0x00	; 0
    13bc:	40 e8       	ldi	r20, 0x80	; 128
    13be:	5f e3       	ldi	r21, 0x3F	; 63
    13c0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    13c4:	88 23       	and	r24, r24
    13c6:	2c f4       	brge	.+10     	; 0x13d2 <LCD_displayCharacter+0x262>
		__ticks = 1;
    13c8:	81 e0       	ldi	r24, 0x01	; 1
    13ca:	90 e0       	ldi	r25, 0x00	; 0
    13cc:	9c 8b       	std	Y+20, r25	; 0x14
    13ce:	8b 8b       	std	Y+19, r24	; 0x13
    13d0:	3f c0       	rjmp	.+126    	; 0x1450 <LCD_displayCharacter+0x2e0>
	else if (__tmp > 65535)
    13d2:	6d 89       	ldd	r22, Y+21	; 0x15
    13d4:	7e 89       	ldd	r23, Y+22	; 0x16
    13d6:	8f 89       	ldd	r24, Y+23	; 0x17
    13d8:	98 8d       	ldd	r25, Y+24	; 0x18
    13da:	20 e0       	ldi	r18, 0x00	; 0
    13dc:	3f ef       	ldi	r19, 0xFF	; 255
    13de:	4f e7       	ldi	r20, 0x7F	; 127
    13e0:	57 e4       	ldi	r21, 0x47	; 71
    13e2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    13e6:	18 16       	cp	r1, r24
    13e8:	4c f5       	brge	.+82     	; 0x143c <LCD_displayCharacter+0x2cc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    13ea:	69 8d       	ldd	r22, Y+25	; 0x19
    13ec:	7a 8d       	ldd	r23, Y+26	; 0x1a
    13ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13f0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    13f2:	20 e0       	ldi	r18, 0x00	; 0
    13f4:	30 e0       	ldi	r19, 0x00	; 0
    13f6:	40 e2       	ldi	r20, 0x20	; 32
    13f8:	51 e4       	ldi	r21, 0x41	; 65
    13fa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13fe:	dc 01       	movw	r26, r24
    1400:	cb 01       	movw	r24, r22
    1402:	bc 01       	movw	r22, r24
    1404:	cd 01       	movw	r24, r26
    1406:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    140a:	dc 01       	movw	r26, r24
    140c:	cb 01       	movw	r24, r22
    140e:	9c 8b       	std	Y+20, r25	; 0x14
    1410:	8b 8b       	std	Y+19, r24	; 0x13
    1412:	0f c0       	rjmp	.+30     	; 0x1432 <LCD_displayCharacter+0x2c2>
    1414:	89 e1       	ldi	r24, 0x19	; 25
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	9a 8b       	std	Y+18, r25	; 0x12
    141a:	89 8b       	std	Y+17, r24	; 0x11
    141c:	89 89       	ldd	r24, Y+17	; 0x11
    141e:	9a 89       	ldd	r25, Y+18	; 0x12
    1420:	01 97       	sbiw	r24, 0x01	; 1
    1422:	f1 f7       	brne	.-4      	; 0x1420 <LCD_displayCharacter+0x2b0>
    1424:	9a 8b       	std	Y+18, r25	; 0x12
    1426:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1428:	8b 89       	ldd	r24, Y+19	; 0x13
    142a:	9c 89       	ldd	r25, Y+20	; 0x14
    142c:	01 97       	sbiw	r24, 0x01	; 1
    142e:	9c 8b       	std	Y+20, r25	; 0x14
    1430:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1432:	8b 89       	ldd	r24, Y+19	; 0x13
    1434:	9c 89       	ldd	r25, Y+20	; 0x14
    1436:	00 97       	sbiw	r24, 0x00	; 0
    1438:	69 f7       	brne	.-38     	; 0x1414 <LCD_displayCharacter+0x2a4>
    143a:	14 c0       	rjmp	.+40     	; 0x1464 <LCD_displayCharacter+0x2f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    143c:	6d 89       	ldd	r22, Y+21	; 0x15
    143e:	7e 89       	ldd	r23, Y+22	; 0x16
    1440:	8f 89       	ldd	r24, Y+23	; 0x17
    1442:	98 8d       	ldd	r25, Y+24	; 0x18
    1444:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1448:	dc 01       	movw	r26, r24
    144a:	cb 01       	movw	r24, r22
    144c:	9c 8b       	std	Y+20, r25	; 0x14
    144e:	8b 8b       	std	Y+19, r24	; 0x13
    1450:	8b 89       	ldd	r24, Y+19	; 0x13
    1452:	9c 89       	ldd	r25, Y+20	; 0x14
    1454:	98 8b       	std	Y+16, r25	; 0x10
    1456:	8f 87       	std	Y+15, r24	; 0x0f
    1458:	8f 85       	ldd	r24, Y+15	; 0x0f
    145a:	98 89       	ldd	r25, Y+16	; 0x10
    145c:	01 97       	sbiw	r24, 0x01	; 1
    145e:	f1 f7       	brne	.-4      	; 0x145c <LCD_displayCharacter+0x2ec>
    1460:	98 8b       	std	Y+16, r25	; 0x10
    1462:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1464:	a2 e3       	ldi	r26, 0x32	; 50
    1466:	b0 e0       	ldi	r27, 0x00	; 0
    1468:	e2 e3       	ldi	r30, 0x32	; 50
    146a:	f0 e0       	ldi	r31, 0x00	; 0
    146c:	80 81       	ld	r24, Z
    146e:	8f 7b       	andi	r24, 0xBF	; 191
    1470:	8c 93       	st	X, r24
    1472:	80 e0       	ldi	r24, 0x00	; 0
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	a0 e8       	ldi	r26, 0x80	; 128
    1478:	bf e3       	ldi	r27, 0x3F	; 63
    147a:	8b 87       	std	Y+11, r24	; 0x0b
    147c:	9c 87       	std	Y+12, r25	; 0x0c
    147e:	ad 87       	std	Y+13, r26	; 0x0d
    1480:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1482:	6b 85       	ldd	r22, Y+11	; 0x0b
    1484:	7c 85       	ldd	r23, Y+12	; 0x0c
    1486:	8d 85       	ldd	r24, Y+13	; 0x0d
    1488:	9e 85       	ldd	r25, Y+14	; 0x0e
    148a:	20 e0       	ldi	r18, 0x00	; 0
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	4a e7       	ldi	r20, 0x7A	; 122
    1490:	53 e4       	ldi	r21, 0x43	; 67
    1492:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1496:	dc 01       	movw	r26, r24
    1498:	cb 01       	movw	r24, r22
    149a:	8f 83       	std	Y+7, r24	; 0x07
    149c:	98 87       	std	Y+8, r25	; 0x08
    149e:	a9 87       	std	Y+9, r26	; 0x09
    14a0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    14a2:	6f 81       	ldd	r22, Y+7	; 0x07
    14a4:	78 85       	ldd	r23, Y+8	; 0x08
    14a6:	89 85       	ldd	r24, Y+9	; 0x09
    14a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    14aa:	20 e0       	ldi	r18, 0x00	; 0
    14ac:	30 e0       	ldi	r19, 0x00	; 0
    14ae:	40 e8       	ldi	r20, 0x80	; 128
    14b0:	5f e3       	ldi	r21, 0x3F	; 63
    14b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    14b6:	88 23       	and	r24, r24
    14b8:	2c f4       	brge	.+10     	; 0x14c4 <LCD_displayCharacter+0x354>
		__ticks = 1;
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	90 e0       	ldi	r25, 0x00	; 0
    14be:	9e 83       	std	Y+6, r25	; 0x06
    14c0:	8d 83       	std	Y+5, r24	; 0x05
    14c2:	3f c0       	rjmp	.+126    	; 0x1542 <LCD_displayCharacter+0x3d2>
	else if (__tmp > 65535)
    14c4:	6f 81       	ldd	r22, Y+7	; 0x07
    14c6:	78 85       	ldd	r23, Y+8	; 0x08
    14c8:	89 85       	ldd	r24, Y+9	; 0x09
    14ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    14cc:	20 e0       	ldi	r18, 0x00	; 0
    14ce:	3f ef       	ldi	r19, 0xFF	; 255
    14d0:	4f e7       	ldi	r20, 0x7F	; 127
    14d2:	57 e4       	ldi	r21, 0x47	; 71
    14d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    14d8:	18 16       	cp	r1, r24
    14da:	4c f5       	brge	.+82     	; 0x152e <LCD_displayCharacter+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    14dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    14de:	7c 85       	ldd	r23, Y+12	; 0x0c
    14e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    14e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    14e4:	20 e0       	ldi	r18, 0x00	; 0
    14e6:	30 e0       	ldi	r19, 0x00	; 0
    14e8:	40 e2       	ldi	r20, 0x20	; 32
    14ea:	51 e4       	ldi	r21, 0x41	; 65
    14ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14f0:	dc 01       	movw	r26, r24
    14f2:	cb 01       	movw	r24, r22
    14f4:	bc 01       	movw	r22, r24
    14f6:	cd 01       	movw	r24, r26
    14f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14fc:	dc 01       	movw	r26, r24
    14fe:	cb 01       	movw	r24, r22
    1500:	9e 83       	std	Y+6, r25	; 0x06
    1502:	8d 83       	std	Y+5, r24	; 0x05
    1504:	0f c0       	rjmp	.+30     	; 0x1524 <LCD_displayCharacter+0x3b4>
    1506:	89 e1       	ldi	r24, 0x19	; 25
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	9c 83       	std	Y+4, r25	; 0x04
    150c:	8b 83       	std	Y+3, r24	; 0x03
    150e:	8b 81       	ldd	r24, Y+3	; 0x03
    1510:	9c 81       	ldd	r25, Y+4	; 0x04
    1512:	01 97       	sbiw	r24, 0x01	; 1
    1514:	f1 f7       	brne	.-4      	; 0x1512 <LCD_displayCharacter+0x3a2>
    1516:	9c 83       	std	Y+4, r25	; 0x04
    1518:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    151a:	8d 81       	ldd	r24, Y+5	; 0x05
    151c:	9e 81       	ldd	r25, Y+6	; 0x06
    151e:	01 97       	sbiw	r24, 0x01	; 1
    1520:	9e 83       	std	Y+6, r25	; 0x06
    1522:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1524:	8d 81       	ldd	r24, Y+5	; 0x05
    1526:	9e 81       	ldd	r25, Y+6	; 0x06
    1528:	00 97       	sbiw	r24, 0x00	; 0
    152a:	69 f7       	brne	.-38     	; 0x1506 <LCD_displayCharacter+0x396>
    152c:	14 c0       	rjmp	.+40     	; 0x1556 <LCD_displayCharacter+0x3e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    152e:	6f 81       	ldd	r22, Y+7	; 0x07
    1530:	78 85       	ldd	r23, Y+8	; 0x08
    1532:	89 85       	ldd	r24, Y+9	; 0x09
    1534:	9a 85       	ldd	r25, Y+10	; 0x0a
    1536:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    153a:	dc 01       	movw	r26, r24
    153c:	cb 01       	movw	r24, r22
    153e:	9e 83       	std	Y+6, r25	; 0x06
    1540:	8d 83       	std	Y+5, r24	; 0x05
    1542:	8d 81       	ldd	r24, Y+5	; 0x05
    1544:	9e 81       	ldd	r25, Y+6	; 0x06
    1546:	9a 83       	std	Y+2, r25	; 0x02
    1548:	89 83       	std	Y+1, r24	; 0x01
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	9a 81       	ldd	r25, Y+2	; 0x02
    154e:	01 97       	sbiw	r24, 0x01	; 1
    1550:	f1 f7       	brne	.-4      	; 0x154e <LCD_displayCharacter+0x3de>
    1552:	9a 83       	std	Y+2, r25	; 0x02
    1554:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
}
    1556:	e9 96       	adiw	r28, 0x39	; 57
    1558:	0f b6       	in	r0, 0x3f	; 63
    155a:	f8 94       	cli
    155c:	de bf       	out	0x3e, r29	; 62
    155e:	0f be       	out	0x3f, r0	; 63
    1560:	cd bf       	out	0x3d, r28	; 61
    1562:	cf 91       	pop	r28
    1564:	df 91       	pop	r29
    1566:	08 95       	ret

00001568 <LCD_displayString>:

void LCD_displayString(const char *Str)
{
    1568:	df 93       	push	r29
    156a:	cf 93       	push	r28
    156c:	00 d0       	rcall	.+0      	; 0x156e <LCD_displayString+0x6>
    156e:	0f 92       	push	r0
    1570:	cd b7       	in	r28, 0x3d	; 61
    1572:	de b7       	in	r29, 0x3e	; 62
    1574:	9b 83       	std	Y+3, r25	; 0x03
    1576:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1578:	19 82       	std	Y+1, r1	; 0x01
    157a:	0e c0       	rjmp	.+28     	; 0x1598 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    157c:	89 81       	ldd	r24, Y+1	; 0x01
    157e:	28 2f       	mov	r18, r24
    1580:	30 e0       	ldi	r19, 0x00	; 0
    1582:	8a 81       	ldd	r24, Y+2	; 0x02
    1584:	9b 81       	ldd	r25, Y+3	; 0x03
    1586:	fc 01       	movw	r30, r24
    1588:	e2 0f       	add	r30, r18
    158a:	f3 1f       	adc	r31, r19
    158c:	80 81       	ld	r24, Z
    158e:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_displayCharacter>
		i++;
    1592:	89 81       	ldd	r24, Y+1	; 0x01
    1594:	8f 5f       	subi	r24, 0xFF	; 255
    1596:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    1598:	89 81       	ldd	r24, Y+1	; 0x01
    159a:	28 2f       	mov	r18, r24
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	8a 81       	ldd	r24, Y+2	; 0x02
    15a0:	9b 81       	ldd	r25, Y+3	; 0x03
    15a2:	fc 01       	movw	r30, r24
    15a4:	e2 0f       	add	r30, r18
    15a6:	f3 1f       	adc	r31, r19
    15a8:	80 81       	ld	r24, Z
    15aa:	88 23       	and	r24, r24
    15ac:	39 f7       	brne	.-50     	; 0x157c <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}
	*********************************************************/
}
    15ae:	0f 90       	pop	r0
    15b0:	0f 90       	pop	r0
    15b2:	0f 90       	pop	r0
    15b4:	cf 91       	pop	r28
    15b6:	df 91       	pop	r29
    15b8:	08 95       	ret

000015ba <LCD_goToRowColumn>:

void LCD_goToRowColumn(uint8 row,uint8 col)
{
    15ba:	df 93       	push	r29
    15bc:	cf 93       	push	r28
    15be:	00 d0       	rcall	.+0      	; 0x15c0 <LCD_goToRowColumn+0x6>
    15c0:	00 d0       	rcall	.+0      	; 0x15c2 <LCD_goToRowColumn+0x8>
    15c2:	0f 92       	push	r0
    15c4:	cd b7       	in	r28, 0x3d	; 61
    15c6:	de b7       	in	r29, 0x3e	; 62
    15c8:	8a 83       	std	Y+2, r24	; 0x02
    15ca:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    15cc:	8a 81       	ldd	r24, Y+2	; 0x02
    15ce:	28 2f       	mov	r18, r24
    15d0:	30 e0       	ldi	r19, 0x00	; 0
    15d2:	3d 83       	std	Y+5, r19	; 0x05
    15d4:	2c 83       	std	Y+4, r18	; 0x04
    15d6:	8c 81       	ldd	r24, Y+4	; 0x04
    15d8:	9d 81       	ldd	r25, Y+5	; 0x05
    15da:	81 30       	cpi	r24, 0x01	; 1
    15dc:	91 05       	cpc	r25, r1
    15de:	c1 f0       	breq	.+48     	; 0x1610 <LCD_goToRowColumn+0x56>
    15e0:	2c 81       	ldd	r18, Y+4	; 0x04
    15e2:	3d 81       	ldd	r19, Y+5	; 0x05
    15e4:	22 30       	cpi	r18, 0x02	; 2
    15e6:	31 05       	cpc	r19, r1
    15e8:	2c f4       	brge	.+10     	; 0x15f4 <LCD_goToRowColumn+0x3a>
    15ea:	8c 81       	ldd	r24, Y+4	; 0x04
    15ec:	9d 81       	ldd	r25, Y+5	; 0x05
    15ee:	00 97       	sbiw	r24, 0x00	; 0
    15f0:	61 f0       	breq	.+24     	; 0x160a <LCD_goToRowColumn+0x50>
    15f2:	19 c0       	rjmp	.+50     	; 0x1626 <LCD_goToRowColumn+0x6c>
    15f4:	2c 81       	ldd	r18, Y+4	; 0x04
    15f6:	3d 81       	ldd	r19, Y+5	; 0x05
    15f8:	22 30       	cpi	r18, 0x02	; 2
    15fa:	31 05       	cpc	r19, r1
    15fc:	69 f0       	breq	.+26     	; 0x1618 <LCD_goToRowColumn+0x5e>
    15fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1600:	9d 81       	ldd	r25, Y+5	; 0x05
    1602:	83 30       	cpi	r24, 0x03	; 3
    1604:	91 05       	cpc	r25, r1
    1606:	61 f0       	breq	.+24     	; 0x1620 <LCD_goToRowColumn+0x66>
    1608:	0e c0       	rjmp	.+28     	; 0x1626 <LCD_goToRowColumn+0x6c>
	{
		case 0:
				Address=col;
    160a:	8b 81       	ldd	r24, Y+3	; 0x03
    160c:	89 83       	std	Y+1, r24	; 0x01
    160e:	0b c0       	rjmp	.+22     	; 0x1626 <LCD_goToRowColumn+0x6c>
				break;
		case 1:
				Address=col+0x40;
    1610:	8b 81       	ldd	r24, Y+3	; 0x03
    1612:	80 5c       	subi	r24, 0xC0	; 192
    1614:	89 83       	std	Y+1, r24	; 0x01
    1616:	07 c0       	rjmp	.+14     	; 0x1626 <LCD_goToRowColumn+0x6c>
				break;
		case 2:
				Address=col+0x10;
    1618:	8b 81       	ldd	r24, Y+3	; 0x03
    161a:	80 5f       	subi	r24, 0xF0	; 240
    161c:	89 83       	std	Y+1, r24	; 0x01
    161e:	03 c0       	rjmp	.+6      	; 0x1626 <LCD_goToRowColumn+0x6c>
				break;
		case 3:
				Address=col+0x50;
    1620:	8b 81       	ldd	r24, Y+3	; 0x03
    1622:	80 5b       	subi	r24, 0xB0	; 176
    1624:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	/* to write to a specific address in the LCD
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION);
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	80 68       	ori	r24, 0x80	; 128
    162a:	0e 94 bc 06 	call	0xd78	; 0xd78 <LCD_sendCommand>
}
    162e:	0f 90       	pop	r0
    1630:	0f 90       	pop	r0
    1632:	0f 90       	pop	r0
    1634:	0f 90       	pop	r0
    1636:	0f 90       	pop	r0
    1638:	cf 91       	pop	r28
    163a:	df 91       	pop	r29
    163c:	08 95       	ret

0000163e <LCD_displayStringRowColumn>:

void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    163e:	df 93       	push	r29
    1640:	cf 93       	push	r28
    1642:	00 d0       	rcall	.+0      	; 0x1644 <LCD_displayStringRowColumn+0x6>
    1644:	00 d0       	rcall	.+0      	; 0x1646 <LCD_displayStringRowColumn+0x8>
    1646:	cd b7       	in	r28, 0x3d	; 61
    1648:	de b7       	in	r29, 0x3e	; 62
    164a:	89 83       	std	Y+1, r24	; 0x01
    164c:	6a 83       	std	Y+2, r22	; 0x02
    164e:	5c 83       	std	Y+4, r21	; 0x04
    1650:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1652:	89 81       	ldd	r24, Y+1	; 0x01
    1654:	6a 81       	ldd	r22, Y+2	; 0x02
    1656:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    165a:	8b 81       	ldd	r24, Y+3	; 0x03
    165c:	9c 81       	ldd	r25, Y+4	; 0x04
    165e:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
}
    1662:	0f 90       	pop	r0
    1664:	0f 90       	pop	r0
    1666:	0f 90       	pop	r0
    1668:	0f 90       	pop	r0
    166a:	cf 91       	pop	r28
    166c:	df 91       	pop	r29
    166e:	08 95       	ret

00001670 <LCD_intgerToString>:

void LCD_intgerToString(int data)
{
    1670:	df 93       	push	r29
    1672:	cf 93       	push	r28
    1674:	cd b7       	in	r28, 0x3d	; 61
    1676:	de b7       	in	r29, 0x3e	; 62
    1678:	62 97       	sbiw	r28, 0x12	; 18
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	de bf       	out	0x3e, r29	; 62
    1680:	0f be       	out	0x3f, r0	; 63
    1682:	cd bf       	out	0x3d, r28	; 61
    1684:	9a 8b       	std	Y+18, r25	; 0x12
    1686:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* 10 for decimal */
    1688:	89 89       	ldd	r24, Y+17	; 0x11
    168a:	9a 89       	ldd	r25, Y+18	; 0x12
    168c:	9e 01       	movw	r18, r28
    168e:	2f 5f       	subi	r18, 0xFF	; 255
    1690:	3f 4f       	sbci	r19, 0xFF	; 255
    1692:	b9 01       	movw	r22, r18
    1694:	4a e0       	ldi	r20, 0x0A	; 10
    1696:	50 e0       	ldi	r21, 0x00	; 0
    1698:	0e 94 18 18 	call	0x3030	; 0x3030 <itoa>
   LCD_displayString(buff);
    169c:	ce 01       	movw	r24, r28
    169e:	01 96       	adiw	r24, 0x01	; 1
    16a0:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
}
    16a4:	62 96       	adiw	r28, 0x12	; 18
    16a6:	0f b6       	in	r0, 0x3f	; 63
    16a8:	f8 94       	cli
    16aa:	de bf       	out	0x3e, r29	; 62
    16ac:	0f be       	out	0x3f, r0	; 63
    16ae:	cd bf       	out	0x3d, r28	; 61
    16b0:	cf 91       	pop	r28
    16b2:	df 91       	pop	r29
    16b4:	08 95       	ret

000016b6 <LCD_clearScreen>:

void LCD_clearScreen(void)
{
    16b6:	df 93       	push	r29
    16b8:	cf 93       	push	r28
    16ba:	cd b7       	in	r28, 0x3d	; 61
    16bc:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	0e 94 bc 06 	call	0xd78	; 0xd78 <LCD_sendCommand>
}
    16c4:	cf 91       	pop	r28
    16c6:	df 91       	pop	r29
    16c8:	08 95       	ret

000016ca <main>:
uint8 flag = 0; /* flag for switch between system setting and sin up function */
uint8 passwordMessage[7];/* contains the string to be sent by UART_sendString() */
uint8 counter=0 , openingMsgFlag =0;

int main (void)
{
    16ca:	df 93       	push	r29
    16cc:	cf 93       	push	r28
    16ce:	0f 92       	push	r0
    16d0:	cd b7       	in	r28, 0x3d	; 61
    16d2:	de b7       	in	r29, 0x3e	; 62

	uint8 val;
	drivers_init();
    16d4:	0e 94 90 0b 	call	0x1720	; 0x1720 <drivers_init>
    //send msg to MC2 to read a value (0x05) from address (0x0D) in exernal EEPROM to check if the first time
	USART_sendByte(FIRST_USE_CHECK);
    16d8:	81 e0       	ldi	r24, 0x01	; 1
    16da:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>
	val = USART_recieveByte();
    16de:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <USART_recieveByte>
    16e2:	89 83       	std	Y+1, r24	; 0x01
	if (val != USED_FIRST)
    16e4:	89 81       	ldd	r24, Y+1	; 0x01
    16e6:	85 30       	cpi	r24, 0x05	; 5
    16e8:	19 f0       	breq	.+6      	; 0x16f0 <main+0x26>
	{
		flag = 0;
    16ea:	10 92 4a 01 	sts	0x014A, r1
    16ee:	06 c0       	rjmp	.+12     	; 0x16fc <main+0x32>

	}
	else if (val == USED_FIRST)
    16f0:	89 81       	ldd	r24, Y+1	; 0x01
    16f2:	85 30       	cpi	r24, 0x05	; 5
    16f4:	19 f4       	brne	.+6      	; 0x16fc <main+0x32>
	{
		flag = 1;
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	80 93 4a 01 	sts	0x014A, r24
	}

	while(1)
	{
	if (flag==0)
    16fc:	80 91 4a 01 	lds	r24, 0x014A
    1700:	88 23       	and	r24, r24
    1702:	19 f4       	brne	.+6      	; 0x170a <main+0x40>
		{
			signUp(); /* sign up function that execute just in first time */
    1704:	0e 94 ac 0b 	call	0x1758	; 0x1758 <signUp>
    1708:	f9 cf       	rjmp	.-14     	; 0x16fc <main+0x32>
		}
		else if (flag==1)
    170a:	80 91 4a 01 	lds	r24, 0x014A
    170e:	81 30       	cpi	r24, 0x01	; 1
    1710:	a9 f7       	brne	.-22     	; 0x16fc <main+0x32>
		{
			if (openingMsgFlag ==0)
    1712:	80 91 4c 01 	lds	r24, 0x014C
    1716:	88 23       	and	r24, r24
    1718:	89 f7       	brne	.-30     	; 0x16fc <main+0x32>
				systemSettings(); /* contain setting of open the door and change password */
    171a:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <systemSettings>
    171e:	ee cf       	rjmp	.-36     	; 0x16fc <main+0x32>

00001720 <drivers_init>:
		}
	}
}
/* Initialization of drivers "LCD , UART " */
void drivers_init()
{
    1720:	df 93       	push	r29
    1722:	cf 93       	push	r28
    1724:	00 d0       	rcall	.+0      	; 0x1726 <drivers_init+0x6>
    1726:	00 d0       	rcall	.+0      	; 0x1728 <drivers_init+0x8>
    1728:	0f 92       	push	r0
    172a:	cd b7       	in	r28, 0x3d	; 61
    172c:	de b7       	in	r29, 0x3e	; 62
	LCD_init();
    172e:	0e 94 a1 06 	call	0xd42	; 0xd42 <LCD_init>

	/* set UART configrations */
	usart_configType UART_configration;
	UART_configration.modeSelect=Asynchronous;
    1732:	1d 82       	std	Y+5, r1	; 0x05
	UART_configration.numOfBits =bit_8;
    1734:	83 e0       	ldi	r24, 0x03	; 3
    1736:	89 83       	std	Y+1, r24	; 0x01
	UART_configration.numOfstopBit= stop_1bit;
    1738:	1b 82       	std	Y+3, r1	; 0x03
	UART_configration.parityBit= No_Parity;
    173a:	1a 82       	std	Y+2, r1	; 0x02
	UART_configration.RX_or_TX=Both_transmition_and_receiver;
    173c:	83 e0       	ldi	r24, 0x03	; 3
    173e:	8c 83       	std	Y+4, r24	; 0x04
	USART_init(&UART_configration);
    1740:	ce 01       	movw	r24, r28
    1742:	01 96       	adiw	r24, 0x01	; 1
    1744:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <USART_init>
}
    1748:	0f 90       	pop	r0
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	0f 90       	pop	r0
    1750:	0f 90       	pop	r0
    1752:	cf 91       	pop	r28
    1754:	df 91       	pop	r29
    1756:	08 95       	ret

00001758 <signUp>:
 * 2. it then convert it to string  , then save the new password again to make a confirmation
 * 3. if there are match ,uart send the new password to MC2 to save it in
 * External EEPROM ,if there are not match the lcd will display invalid match .
 */
void signUp()
{
    1758:	df 93       	push	r29
    175a:	cf 93       	push	r28
    175c:	cd b7       	in	r28, 0x3d	; 61
    175e:	de b7       	in	r29, 0x3e	; 62
    1760:	c4 54       	subi	r28, 0x44	; 68
    1762:	d0 40       	sbci	r29, 0x00	; 0
    1764:	0f b6       	in	r0, 0x3f	; 63
    1766:	f8 94       	cli
    1768:	de bf       	out	0x3e, r29	; 62
    176a:	0f be       	out	0x3f, r0	; 63
    176c:	cd bf       	out	0x3d, r28	; 61
	uint8 passwordCode1[6] = {0},  passwordCode2[6] = {0}; /* two buffer for save the new password and its confirmation */
    176e:	86 e0       	ldi	r24, 0x06	; 6
    1770:	fe 01       	movw	r30, r28
    1772:	f9 96       	adiw	r30, 0x39	; 57
    1774:	df 01       	movw	r26, r30
    1776:	98 2f       	mov	r25, r24
    1778:	1d 92       	st	X+, r1
    177a:	9a 95       	dec	r25
    177c:	e9 f7       	brne	.-6      	; 0x1778 <signUp+0x20>
    177e:	86 e0       	ldi	r24, 0x06	; 6
    1780:	fe 01       	movw	r30, r28
    1782:	ff 96       	adiw	r30, 0x3f	; 63
    1784:	df 01       	movw	r26, r30
    1786:	98 2f       	mov	r25, r24
    1788:	1d 92       	st	X+, r1
    178a:	9a 95       	dec	r25
    178c:	e9 f7       	brne	.-6      	; 0x1788 <signUp+0x30>
	/*LCD_displayString("Welcome to Our ");
	LCD_goToRowColumn(1, 0);
	LCD_displayString("system");
	LCD_clearScreen();*/

	LCD_displayString("Please enter new");/* display that string */
    178e:	80 e6       	ldi	r24, 0x60	; 96
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
	LCD_goToRowColumn(1, 0);
    1796:	81 e0       	ldi	r24, 0x01	; 1
    1798:	60 e0       	ldi	r22, 0x00	; 0
    179a:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <LCD_goToRowColumn>
	LCD_displayString("password (5 Num)");
    179e:	81 e7       	ldi	r24, 0x71	; 113
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    17a6:	80 e0       	ldi	r24, 0x00	; 0
    17a8:	90 e0       	ldi	r25, 0x00	; 0
    17aa:	aa e7       	ldi	r26, 0x7A	; 122
    17ac:	b4 e4       	ldi	r27, 0x44	; 68
    17ae:	8d ab       	std	Y+53, r24	; 0x35
    17b0:	9e ab       	std	Y+54, r25	; 0x36
    17b2:	af ab       	std	Y+55, r26	; 0x37
    17b4:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17b6:	6d a9       	ldd	r22, Y+53	; 0x35
    17b8:	7e a9       	ldd	r23, Y+54	; 0x36
    17ba:	8f a9       	ldd	r24, Y+55	; 0x37
    17bc:	98 ad       	ldd	r25, Y+56	; 0x38
    17be:	20 e0       	ldi	r18, 0x00	; 0
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	4a e7       	ldi	r20, 0x7A	; 122
    17c4:	53 e4       	ldi	r21, 0x43	; 67
    17c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17ca:	dc 01       	movw	r26, r24
    17cc:	cb 01       	movw	r24, r22
    17ce:	89 ab       	std	Y+49, r24	; 0x31
    17d0:	9a ab       	std	Y+50, r25	; 0x32
    17d2:	ab ab       	std	Y+51, r26	; 0x33
    17d4:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    17d6:	69 a9       	ldd	r22, Y+49	; 0x31
    17d8:	7a a9       	ldd	r23, Y+50	; 0x32
    17da:	8b a9       	ldd	r24, Y+51	; 0x33
    17dc:	9c a9       	ldd	r25, Y+52	; 0x34
    17de:	20 e0       	ldi	r18, 0x00	; 0
    17e0:	30 e0       	ldi	r19, 0x00	; 0
    17e2:	40 e8       	ldi	r20, 0x80	; 128
    17e4:	5f e3       	ldi	r21, 0x3F	; 63
    17e6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17ea:	88 23       	and	r24, r24
    17ec:	2c f4       	brge	.+10     	; 0x17f8 <signUp+0xa0>
		__ticks = 1;
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	90 e0       	ldi	r25, 0x00	; 0
    17f2:	98 ab       	std	Y+48, r25	; 0x30
    17f4:	8f a7       	std	Y+47, r24	; 0x2f
    17f6:	3f c0       	rjmp	.+126    	; 0x1876 <signUp+0x11e>
	else if (__tmp > 65535)
    17f8:	69 a9       	ldd	r22, Y+49	; 0x31
    17fa:	7a a9       	ldd	r23, Y+50	; 0x32
    17fc:	8b a9       	ldd	r24, Y+51	; 0x33
    17fe:	9c a9       	ldd	r25, Y+52	; 0x34
    1800:	20 e0       	ldi	r18, 0x00	; 0
    1802:	3f ef       	ldi	r19, 0xFF	; 255
    1804:	4f e7       	ldi	r20, 0x7F	; 127
    1806:	57 e4       	ldi	r21, 0x47	; 71
    1808:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    180c:	18 16       	cp	r1, r24
    180e:	4c f5       	brge	.+82     	; 0x1862 <signUp+0x10a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1810:	6d a9       	ldd	r22, Y+53	; 0x35
    1812:	7e a9       	ldd	r23, Y+54	; 0x36
    1814:	8f a9       	ldd	r24, Y+55	; 0x37
    1816:	98 ad       	ldd	r25, Y+56	; 0x38
    1818:	20 e0       	ldi	r18, 0x00	; 0
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	40 e2       	ldi	r20, 0x20	; 32
    181e:	51 e4       	ldi	r21, 0x41	; 65
    1820:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1824:	dc 01       	movw	r26, r24
    1826:	cb 01       	movw	r24, r22
    1828:	bc 01       	movw	r22, r24
    182a:	cd 01       	movw	r24, r26
    182c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1830:	dc 01       	movw	r26, r24
    1832:	cb 01       	movw	r24, r22
    1834:	98 ab       	std	Y+48, r25	; 0x30
    1836:	8f a7       	std	Y+47, r24	; 0x2f
    1838:	0f c0       	rjmp	.+30     	; 0x1858 <signUp+0x100>
    183a:	89 e1       	ldi	r24, 0x19	; 25
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	9e a7       	std	Y+46, r25	; 0x2e
    1840:	8d a7       	std	Y+45, r24	; 0x2d
    1842:	8d a5       	ldd	r24, Y+45	; 0x2d
    1844:	9e a5       	ldd	r25, Y+46	; 0x2e
    1846:	01 97       	sbiw	r24, 0x01	; 1
    1848:	f1 f7       	brne	.-4      	; 0x1846 <signUp+0xee>
    184a:	9e a7       	std	Y+46, r25	; 0x2e
    184c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    184e:	8f a5       	ldd	r24, Y+47	; 0x2f
    1850:	98 a9       	ldd	r25, Y+48	; 0x30
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	98 ab       	std	Y+48, r25	; 0x30
    1856:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1858:	8f a5       	ldd	r24, Y+47	; 0x2f
    185a:	98 a9       	ldd	r25, Y+48	; 0x30
    185c:	00 97       	sbiw	r24, 0x00	; 0
    185e:	69 f7       	brne	.-38     	; 0x183a <signUp+0xe2>
    1860:	14 c0       	rjmp	.+40     	; 0x188a <signUp+0x132>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1862:	69 a9       	ldd	r22, Y+49	; 0x31
    1864:	7a a9       	ldd	r23, Y+50	; 0x32
    1866:	8b a9       	ldd	r24, Y+51	; 0x33
    1868:	9c a9       	ldd	r25, Y+52	; 0x34
    186a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    186e:	dc 01       	movw	r26, r24
    1870:	cb 01       	movw	r24, r22
    1872:	98 ab       	std	Y+48, r25	; 0x30
    1874:	8f a7       	std	Y+47, r24	; 0x2f
    1876:	8f a5       	ldd	r24, Y+47	; 0x2f
    1878:	98 a9       	ldd	r25, Y+48	; 0x30
    187a:	9c a7       	std	Y+44, r25	; 0x2c
    187c:	8b a7       	std	Y+43, r24	; 0x2b
    187e:	8b a5       	ldd	r24, Y+43	; 0x2b
    1880:	9c a5       	ldd	r25, Y+44	; 0x2c
    1882:	01 97       	sbiw	r24, 0x01	; 1
    1884:	f1 f7       	brne	.-4      	; 0x1882 <signUp+0x12a>
    1886:	9c a7       	std	Y+44, r25	; 0x2c
    1888:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1000);
	LCD_clearScreen();
    188a:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>

	enterPassword(&passwordCode1); /* save password in buffer after convert it to string */
    188e:	ce 01       	movw	r24, r28
    1890:	c9 96       	adiw	r24, 0x39	; 57
    1892:	0e 94 b6 12 	call	0x256c	; 0x256c <enterPassword>


	while (1)
	{

		LCD_clearScreen();
    1896:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
		LCD_displayString("Please rewrite password ");
    189a:	82 e8       	ldi	r24, 0x82	; 130
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
		LCD_goToRowColumn(1, 0);
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	60 e0       	ldi	r22, 0x00	; 0
    18a6:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <LCD_goToRowColumn>
		LCD_displayString("password (5 Num)");
    18aa:	81 e7       	ldi	r24, 0x71	; 113
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    18b2:	80 e0       	ldi	r24, 0x00	; 0
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	aa e7       	ldi	r26, 0x7A	; 122
    18b8:	b4 e4       	ldi	r27, 0x44	; 68
    18ba:	8f a3       	std	Y+39, r24	; 0x27
    18bc:	98 a7       	std	Y+40, r25	; 0x28
    18be:	a9 a7       	std	Y+41, r26	; 0x29
    18c0:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    18c2:	6f a1       	ldd	r22, Y+39	; 0x27
    18c4:	78 a5       	ldd	r23, Y+40	; 0x28
    18c6:	89 a5       	ldd	r24, Y+41	; 0x29
    18c8:	9a a5       	ldd	r25, Y+42	; 0x2a
    18ca:	20 e0       	ldi	r18, 0x00	; 0
    18cc:	30 e0       	ldi	r19, 0x00	; 0
    18ce:	4a e7       	ldi	r20, 0x7A	; 122
    18d0:	53 e4       	ldi	r21, 0x43	; 67
    18d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18d6:	dc 01       	movw	r26, r24
    18d8:	cb 01       	movw	r24, r22
    18da:	8b a3       	std	Y+35, r24	; 0x23
    18dc:	9c a3       	std	Y+36, r25	; 0x24
    18de:	ad a3       	std	Y+37, r26	; 0x25
    18e0:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    18e2:	6b a1       	ldd	r22, Y+35	; 0x23
    18e4:	7c a1       	ldd	r23, Y+36	; 0x24
    18e6:	8d a1       	ldd	r24, Y+37	; 0x25
    18e8:	9e a1       	ldd	r25, Y+38	; 0x26
    18ea:	20 e0       	ldi	r18, 0x00	; 0
    18ec:	30 e0       	ldi	r19, 0x00	; 0
    18ee:	40 e8       	ldi	r20, 0x80	; 128
    18f0:	5f e3       	ldi	r21, 0x3F	; 63
    18f2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    18f6:	88 23       	and	r24, r24
    18f8:	2c f4       	brge	.+10     	; 0x1904 <signUp+0x1ac>
		__ticks = 1;
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	9a a3       	std	Y+34, r25	; 0x22
    1900:	89 a3       	std	Y+33, r24	; 0x21
    1902:	3f c0       	rjmp	.+126    	; 0x1982 <signUp+0x22a>
	else if (__tmp > 65535)
    1904:	6b a1       	ldd	r22, Y+35	; 0x23
    1906:	7c a1       	ldd	r23, Y+36	; 0x24
    1908:	8d a1       	ldd	r24, Y+37	; 0x25
    190a:	9e a1       	ldd	r25, Y+38	; 0x26
    190c:	20 e0       	ldi	r18, 0x00	; 0
    190e:	3f ef       	ldi	r19, 0xFF	; 255
    1910:	4f e7       	ldi	r20, 0x7F	; 127
    1912:	57 e4       	ldi	r21, 0x47	; 71
    1914:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1918:	18 16       	cp	r1, r24
    191a:	4c f5       	brge	.+82     	; 0x196e <signUp+0x216>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    191c:	6f a1       	ldd	r22, Y+39	; 0x27
    191e:	78 a5       	ldd	r23, Y+40	; 0x28
    1920:	89 a5       	ldd	r24, Y+41	; 0x29
    1922:	9a a5       	ldd	r25, Y+42	; 0x2a
    1924:	20 e0       	ldi	r18, 0x00	; 0
    1926:	30 e0       	ldi	r19, 0x00	; 0
    1928:	40 e2       	ldi	r20, 0x20	; 32
    192a:	51 e4       	ldi	r21, 0x41	; 65
    192c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1930:	dc 01       	movw	r26, r24
    1932:	cb 01       	movw	r24, r22
    1934:	bc 01       	movw	r22, r24
    1936:	cd 01       	movw	r24, r26
    1938:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    193c:	dc 01       	movw	r26, r24
    193e:	cb 01       	movw	r24, r22
    1940:	9a a3       	std	Y+34, r25	; 0x22
    1942:	89 a3       	std	Y+33, r24	; 0x21
    1944:	0f c0       	rjmp	.+30     	; 0x1964 <signUp+0x20c>
    1946:	89 e1       	ldi	r24, 0x19	; 25
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	98 a3       	std	Y+32, r25	; 0x20
    194c:	8f 8f       	std	Y+31, r24	; 0x1f
    194e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1950:	98 a1       	ldd	r25, Y+32	; 0x20
    1952:	01 97       	sbiw	r24, 0x01	; 1
    1954:	f1 f7       	brne	.-4      	; 0x1952 <signUp+0x1fa>
    1956:	98 a3       	std	Y+32, r25	; 0x20
    1958:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    195a:	89 a1       	ldd	r24, Y+33	; 0x21
    195c:	9a a1       	ldd	r25, Y+34	; 0x22
    195e:	01 97       	sbiw	r24, 0x01	; 1
    1960:	9a a3       	std	Y+34, r25	; 0x22
    1962:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1964:	89 a1       	ldd	r24, Y+33	; 0x21
    1966:	9a a1       	ldd	r25, Y+34	; 0x22
    1968:	00 97       	sbiw	r24, 0x00	; 0
    196a:	69 f7       	brne	.-38     	; 0x1946 <signUp+0x1ee>
    196c:	14 c0       	rjmp	.+40     	; 0x1996 <signUp+0x23e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    196e:	6b a1       	ldd	r22, Y+35	; 0x23
    1970:	7c a1       	ldd	r23, Y+36	; 0x24
    1972:	8d a1       	ldd	r24, Y+37	; 0x25
    1974:	9e a1       	ldd	r25, Y+38	; 0x26
    1976:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    197a:	dc 01       	movw	r26, r24
    197c:	cb 01       	movw	r24, r22
    197e:	9a a3       	std	Y+34, r25	; 0x22
    1980:	89 a3       	std	Y+33, r24	; 0x21
    1982:	89 a1       	ldd	r24, Y+33	; 0x21
    1984:	9a a1       	ldd	r25, Y+34	; 0x22
    1986:	9e 8f       	std	Y+30, r25	; 0x1e
    1988:	8d 8f       	std	Y+29, r24	; 0x1d
    198a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    198c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    198e:	01 97       	sbiw	r24, 0x01	; 1
    1990:	f1 f7       	brne	.-4      	; 0x198e <signUp+0x236>
    1992:	9e 8f       	std	Y+30, r25	; 0x1e
    1994:	8d 8f       	std	Y+29, r24	; 0x1d
		_delay_ms(1000);
		LCD_clearScreen();
    1996:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>

		enterPassword(&passwordCode2);
    199a:	ce 01       	movw	r24, r28
    199c:	cf 96       	adiw	r24, 0x3f	; 63
    199e:	0e 94 b6 12 	call	0x256c	; 0x256c <enterPassword>
		LCD_clearScreen();
    19a2:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>

		if (strcmp(passwordCode1 , passwordCode2)==0) /* if the two password are identical and Matching */
    19a6:	ce 01       	movw	r24, r28
    19a8:	c9 96       	adiw	r24, 0x39	; 57
    19aa:	9e 01       	movw	r18, r28
    19ac:	21 5c       	subi	r18, 0xC1	; 193
    19ae:	3f 4f       	sbci	r19, 0xFF	; 255
    19b0:	b9 01       	movw	r22, r18
    19b2:	0e 94 0f 18 	call	0x301e	; 0x301e <strcmp>
    19b6:	00 97       	sbiw	r24, 0x00	; 0
    19b8:	09 f0       	breq	.+2      	; 0x19bc <signUp+0x264>
    19ba:	91 c0       	rjmp	.+290    	; 0x1ade <signUp+0x386>
		{
	       /*send msg to MC2 to write a fixed value (USED_FIRST) in address (INTERNA_EEPROM_ADDRESS) of Internal EEPROM to check it in the first time of the program */
		    USART_sendByte(SET_FIRST_USE);
    19bc:	82 e0       	ldi	r24, 0x02	; 2
    19be:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>
			flag = 1; /* make the flag =1 it mean the sign up function will not execute again and the system function it will be execute in the second time of program */
    19c2:	81 e0       	ldi	r24, 0x01	; 1
    19c4:	80 93 4a 01 	sts	0x014A, r24
			LCD_clearScreen();
    19c8:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
			LCD_displayString(" Done ");
    19cc:	8b e9       	ldi	r24, 0x9B	; 155
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
			LCD_displayString(passwordCode1);
    19d4:	ce 01       	movw	r24, r28
    19d6:	c9 96       	adiw	r24, 0x39	; 57
    19d8:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
			prepareToSend(passwordCode1,passwordMessage); /* add # to the new password in the buffer that is save in to prepare send it by uart to MC2 */
    19dc:	ce 01       	movw	r24, r28
    19de:	c9 96       	adiw	r24, 0x39	; 57
    19e0:	23 e5       	ldi	r18, 0x53	; 83
    19e2:	31 e0       	ldi	r19, 0x01	; 1
    19e4:	b9 01       	movw	r22, r18
    19e6:	0e 94 63 13 	call	0x26c6	; 0x26c6 <prepareToSend>
			USART_sendByte(SAVE_PASS); /* send msg to MC2 to can understand that it will SAVE Password now in External EEPROM */
    19ea:	8b e0       	ldi	r24, 0x0B	; 11
    19ec:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>
			USART_sendString(passwordMessage);/* uart send the new password to MC2 save it in the External EEPROM */
    19f0:	83 e5       	ldi	r24, 0x53	; 83
    19f2:	91 e0       	ldi	r25, 0x01	; 1
    19f4:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <USART_sendString>
    19f8:	80 e0       	ldi	r24, 0x00	; 0
    19fa:	90 e0       	ldi	r25, 0x00	; 0
    19fc:	aa e7       	ldi	r26, 0x7A	; 122
    19fe:	b4 e4       	ldi	r27, 0x44	; 68
    1a00:	89 8f       	std	Y+25, r24	; 0x19
    1a02:	9a 8f       	std	Y+26, r25	; 0x1a
    1a04:	ab 8f       	std	Y+27, r26	; 0x1b
    1a06:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a08:	69 8d       	ldd	r22, Y+25	; 0x19
    1a0a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1a0c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a0e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1a10:	20 e0       	ldi	r18, 0x00	; 0
    1a12:	30 e0       	ldi	r19, 0x00	; 0
    1a14:	4a e7       	ldi	r20, 0x7A	; 122
    1a16:	53 e4       	ldi	r21, 0x43	; 67
    1a18:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a1c:	dc 01       	movw	r26, r24
    1a1e:	cb 01       	movw	r24, r22
    1a20:	8d 8b       	std	Y+21, r24	; 0x15
    1a22:	9e 8b       	std	Y+22, r25	; 0x16
    1a24:	af 8b       	std	Y+23, r26	; 0x17
    1a26:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1a28:	6d 89       	ldd	r22, Y+21	; 0x15
    1a2a:	7e 89       	ldd	r23, Y+22	; 0x16
    1a2c:	8f 89       	ldd	r24, Y+23	; 0x17
    1a2e:	98 8d       	ldd	r25, Y+24	; 0x18
    1a30:	20 e0       	ldi	r18, 0x00	; 0
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	40 e8       	ldi	r20, 0x80	; 128
    1a36:	5f e3       	ldi	r21, 0x3F	; 63
    1a38:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a3c:	88 23       	and	r24, r24
    1a3e:	2c f4       	brge	.+10     	; 0x1a4a <signUp+0x2f2>
		__ticks = 1;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	9c 8b       	std	Y+20, r25	; 0x14
    1a46:	8b 8b       	std	Y+19, r24	; 0x13
    1a48:	3f c0       	rjmp	.+126    	; 0x1ac8 <signUp+0x370>
	else if (__tmp > 65535)
    1a4a:	6d 89       	ldd	r22, Y+21	; 0x15
    1a4c:	7e 89       	ldd	r23, Y+22	; 0x16
    1a4e:	8f 89       	ldd	r24, Y+23	; 0x17
    1a50:	98 8d       	ldd	r25, Y+24	; 0x18
    1a52:	20 e0       	ldi	r18, 0x00	; 0
    1a54:	3f ef       	ldi	r19, 0xFF	; 255
    1a56:	4f e7       	ldi	r20, 0x7F	; 127
    1a58:	57 e4       	ldi	r21, 0x47	; 71
    1a5a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a5e:	18 16       	cp	r1, r24
    1a60:	4c f5       	brge	.+82     	; 0x1ab4 <signUp+0x35c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a62:	69 8d       	ldd	r22, Y+25	; 0x19
    1a64:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1a66:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a68:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1a6a:	20 e0       	ldi	r18, 0x00	; 0
    1a6c:	30 e0       	ldi	r19, 0x00	; 0
    1a6e:	40 e2       	ldi	r20, 0x20	; 32
    1a70:	51 e4       	ldi	r21, 0x41	; 65
    1a72:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a76:	dc 01       	movw	r26, r24
    1a78:	cb 01       	movw	r24, r22
    1a7a:	bc 01       	movw	r22, r24
    1a7c:	cd 01       	movw	r24, r26
    1a7e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a82:	dc 01       	movw	r26, r24
    1a84:	cb 01       	movw	r24, r22
    1a86:	9c 8b       	std	Y+20, r25	; 0x14
    1a88:	8b 8b       	std	Y+19, r24	; 0x13
    1a8a:	0f c0       	rjmp	.+30     	; 0x1aaa <signUp+0x352>
    1a8c:	89 e1       	ldi	r24, 0x19	; 25
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	9a 8b       	std	Y+18, r25	; 0x12
    1a92:	89 8b       	std	Y+17, r24	; 0x11
    1a94:	89 89       	ldd	r24, Y+17	; 0x11
    1a96:	9a 89       	ldd	r25, Y+18	; 0x12
    1a98:	01 97       	sbiw	r24, 0x01	; 1
    1a9a:	f1 f7       	brne	.-4      	; 0x1a98 <signUp+0x340>
    1a9c:	9a 8b       	std	Y+18, r25	; 0x12
    1a9e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1aa0:	8b 89       	ldd	r24, Y+19	; 0x13
    1aa2:	9c 89       	ldd	r25, Y+20	; 0x14
    1aa4:	01 97       	sbiw	r24, 0x01	; 1
    1aa6:	9c 8b       	std	Y+20, r25	; 0x14
    1aa8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1aaa:	8b 89       	ldd	r24, Y+19	; 0x13
    1aac:	9c 89       	ldd	r25, Y+20	; 0x14
    1aae:	00 97       	sbiw	r24, 0x00	; 0
    1ab0:	69 f7       	brne	.-38     	; 0x1a8c <signUp+0x334>
    1ab2:	8c c0       	rjmp	.+280    	; 0x1bcc <signUp+0x474>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ab4:	6d 89       	ldd	r22, Y+21	; 0x15
    1ab6:	7e 89       	ldd	r23, Y+22	; 0x16
    1ab8:	8f 89       	ldd	r24, Y+23	; 0x17
    1aba:	98 8d       	ldd	r25, Y+24	; 0x18
    1abc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ac0:	dc 01       	movw	r26, r24
    1ac2:	cb 01       	movw	r24, r22
    1ac4:	9c 8b       	std	Y+20, r25	; 0x14
    1ac6:	8b 8b       	std	Y+19, r24	; 0x13
    1ac8:	8b 89       	ldd	r24, Y+19	; 0x13
    1aca:	9c 89       	ldd	r25, Y+20	; 0x14
    1acc:	98 8b       	std	Y+16, r25	; 0x10
    1ace:	8f 87       	std	Y+15, r24	; 0x0f
    1ad0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ad2:	98 89       	ldd	r25, Y+16	; 0x10
    1ad4:	01 97       	sbiw	r24, 0x01	; 1
    1ad6:	f1 f7       	brne	.-4      	; 0x1ad4 <signUp+0x37c>
    1ad8:	98 8b       	std	Y+16, r25	; 0x10
    1ada:	8f 87       	std	Y+15, r24	; 0x0f
    1adc:	77 c0       	rjmp	.+238    	; 0x1bcc <signUp+0x474>
		}
		else
		{
			/* to repeat again the sign up function */
			//flag=0;
			LCD_displayString("invalid match");
    1ade:	82 ea       	ldi	r24, 0xA2	; 162
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    1ae6:	80 e0       	ldi	r24, 0x00	; 0
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	aa e7       	ldi	r26, 0x7A	; 122
    1aec:	b4 e4       	ldi	r27, 0x44	; 68
    1aee:	8b 87       	std	Y+11, r24	; 0x0b
    1af0:	9c 87       	std	Y+12, r25	; 0x0c
    1af2:	ad 87       	std	Y+13, r26	; 0x0d
    1af4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1af6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1af8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1afa:	8d 85       	ldd	r24, Y+13	; 0x0d
    1afc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1afe:	20 e0       	ldi	r18, 0x00	; 0
    1b00:	30 e0       	ldi	r19, 0x00	; 0
    1b02:	4a e7       	ldi	r20, 0x7A	; 122
    1b04:	53 e4       	ldi	r21, 0x43	; 67
    1b06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b0a:	dc 01       	movw	r26, r24
    1b0c:	cb 01       	movw	r24, r22
    1b0e:	8f 83       	std	Y+7, r24	; 0x07
    1b10:	98 87       	std	Y+8, r25	; 0x08
    1b12:	a9 87       	std	Y+9, r26	; 0x09
    1b14:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1b16:	6f 81       	ldd	r22, Y+7	; 0x07
    1b18:	78 85       	ldd	r23, Y+8	; 0x08
    1b1a:	89 85       	ldd	r24, Y+9	; 0x09
    1b1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b1e:	20 e0       	ldi	r18, 0x00	; 0
    1b20:	30 e0       	ldi	r19, 0x00	; 0
    1b22:	40 e8       	ldi	r20, 0x80	; 128
    1b24:	5f e3       	ldi	r21, 0x3F	; 63
    1b26:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b2a:	88 23       	and	r24, r24
    1b2c:	2c f4       	brge	.+10     	; 0x1b38 <signUp+0x3e0>
		__ticks = 1;
    1b2e:	81 e0       	ldi	r24, 0x01	; 1
    1b30:	90 e0       	ldi	r25, 0x00	; 0
    1b32:	9e 83       	std	Y+6, r25	; 0x06
    1b34:	8d 83       	std	Y+5, r24	; 0x05
    1b36:	3f c0       	rjmp	.+126    	; 0x1bb6 <signUp+0x45e>
	else if (__tmp > 65535)
    1b38:	6f 81       	ldd	r22, Y+7	; 0x07
    1b3a:	78 85       	ldd	r23, Y+8	; 0x08
    1b3c:	89 85       	ldd	r24, Y+9	; 0x09
    1b3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b40:	20 e0       	ldi	r18, 0x00	; 0
    1b42:	3f ef       	ldi	r19, 0xFF	; 255
    1b44:	4f e7       	ldi	r20, 0x7F	; 127
    1b46:	57 e4       	ldi	r21, 0x47	; 71
    1b48:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b4c:	18 16       	cp	r1, r24
    1b4e:	4c f5       	brge	.+82     	; 0x1ba2 <signUp+0x44a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b50:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b52:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b54:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b56:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b58:	20 e0       	ldi	r18, 0x00	; 0
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	40 e2       	ldi	r20, 0x20	; 32
    1b5e:	51 e4       	ldi	r21, 0x41	; 65
    1b60:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b64:	dc 01       	movw	r26, r24
    1b66:	cb 01       	movw	r24, r22
    1b68:	bc 01       	movw	r22, r24
    1b6a:	cd 01       	movw	r24, r26
    1b6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b70:	dc 01       	movw	r26, r24
    1b72:	cb 01       	movw	r24, r22
    1b74:	9e 83       	std	Y+6, r25	; 0x06
    1b76:	8d 83       	std	Y+5, r24	; 0x05
    1b78:	0f c0       	rjmp	.+30     	; 0x1b98 <signUp+0x440>
    1b7a:	89 e1       	ldi	r24, 0x19	; 25
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	9c 83       	std	Y+4, r25	; 0x04
    1b80:	8b 83       	std	Y+3, r24	; 0x03
    1b82:	8b 81       	ldd	r24, Y+3	; 0x03
    1b84:	9c 81       	ldd	r25, Y+4	; 0x04
    1b86:	01 97       	sbiw	r24, 0x01	; 1
    1b88:	f1 f7       	brne	.-4      	; 0x1b86 <signUp+0x42e>
    1b8a:	9c 83       	std	Y+4, r25	; 0x04
    1b8c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b8e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b90:	9e 81       	ldd	r25, Y+6	; 0x06
    1b92:	01 97       	sbiw	r24, 0x01	; 1
    1b94:	9e 83       	std	Y+6, r25	; 0x06
    1b96:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b98:	8d 81       	ldd	r24, Y+5	; 0x05
    1b9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9c:	00 97       	sbiw	r24, 0x00	; 0
    1b9e:	69 f7       	brne	.-38     	; 0x1b7a <signUp+0x422>
    1ba0:	7a ce       	rjmp	.-780    	; 0x1896 <signUp+0x13e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ba2:	6f 81       	ldd	r22, Y+7	; 0x07
    1ba4:	78 85       	ldd	r23, Y+8	; 0x08
    1ba6:	89 85       	ldd	r24, Y+9	; 0x09
    1ba8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1baa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bae:	dc 01       	movw	r26, r24
    1bb0:	cb 01       	movw	r24, r22
    1bb2:	9e 83       	std	Y+6, r25	; 0x06
    1bb4:	8d 83       	std	Y+5, r24	; 0x05
    1bb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bb8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bba:	9a 83       	std	Y+2, r25	; 0x02
    1bbc:	89 83       	std	Y+1, r24	; 0x01
    1bbe:	89 81       	ldd	r24, Y+1	; 0x01
    1bc0:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc2:	01 97       	sbiw	r24, 0x01	; 1
    1bc4:	f1 f7       	brne	.-4      	; 0x1bc2 <signUp+0x46a>
    1bc6:	9a 83       	std	Y+2, r25	; 0x02
    1bc8:	89 83       	std	Y+1, r24	; 0x01
    1bca:	65 ce       	rjmp	.-822    	; 0x1896 <signUp+0x13e>
			_delay_ms(1000);
		}
	}
}
    1bcc:	cc 5b       	subi	r28, 0xBC	; 188
    1bce:	df 4f       	sbci	r29, 0xFF	; 255
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	de bf       	out	0x3e, r29	; 62
    1bd6:	0f be       	out	0x3f, r0	; 63
    1bd8:	cd bf       	out	0x3d, r28	; 61
    1bda:	cf 91       	pop	r28
    1bdc:	df 91       	pop	r29
    1bde:	08 95       	ret

00001be0 <systemSettings>:
/* system settings function that contain some setting :
 * 1. open the door by  press x
 * 2. change password by press +
 * */
void systemSettings()
{
    1be0:	0f 93       	push	r16
    1be2:	1f 93       	push	r17
    1be4:	df 93       	push	r29
    1be6:	cf 93       	push	r28
    1be8:	cd b7       	in	r28, 0x3d	; 61
    1bea:	de b7       	in	r29, 0x3e	; 62
    1bec:	c7 57       	subi	r28, 0x77	; 119
    1bee:	d0 40       	sbci	r29, 0x00	; 0
    1bf0:	0f b6       	in	r0, 0x3f	; 63
    1bf2:	f8 94       	cli
    1bf4:	de bf       	out	0x3e, r29	; 62
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	cd bf       	out	0x3d, r28	; 61
	uint8 passwordCode[6];
	uint8 oldPassword[6] , count =0;
    1bfa:	fe 01       	movw	r30, r28
    1bfc:	eb 59       	subi	r30, 0x9B	; 155
    1bfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1c00:	10 82       	st	Z, r1
	LCD_clearScreen();
    1c02:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>

	LCD_displayString("open the door ");
    1c06:	80 eb       	ldi	r24, 0xB0	; 176
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
	LCD_goToRowColumn(1 ,0);
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
    1c10:	60 e0       	ldi	r22, 0x00	; 0
    1c12:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <LCD_goToRowColumn>
	LCD_displayString("(press X )");
    1c16:	8f eb       	ldi	r24, 0xBF	; 191
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    1c1e:	fe 01       	movw	r30, r28
    1c20:	e1 5a       	subi	r30, 0xA1	; 161
    1c22:	ff 4f       	sbci	r31, 0xFF	; 255
    1c24:	80 e0       	ldi	r24, 0x00	; 0
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	a8 e4       	ldi	r26, 0x48	; 72
    1c2a:	b4 e4       	ldi	r27, 0x44	; 68
    1c2c:	80 83       	st	Z, r24
    1c2e:	91 83       	std	Z+1, r25	; 0x01
    1c30:	a2 83       	std	Z+2, r26	; 0x02
    1c32:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c34:	8e 01       	movw	r16, r28
    1c36:	05 5a       	subi	r16, 0xA5	; 165
    1c38:	1f 4f       	sbci	r17, 0xFF	; 255
    1c3a:	fe 01       	movw	r30, r28
    1c3c:	e1 5a       	subi	r30, 0xA1	; 161
    1c3e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c40:	60 81       	ld	r22, Z
    1c42:	71 81       	ldd	r23, Z+1	; 0x01
    1c44:	82 81       	ldd	r24, Z+2	; 0x02
    1c46:	93 81       	ldd	r25, Z+3	; 0x03
    1c48:	20 e0       	ldi	r18, 0x00	; 0
    1c4a:	30 e0       	ldi	r19, 0x00	; 0
    1c4c:	4a e7       	ldi	r20, 0x7A	; 122
    1c4e:	53 e4       	ldi	r21, 0x43	; 67
    1c50:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c54:	dc 01       	movw	r26, r24
    1c56:	cb 01       	movw	r24, r22
    1c58:	f8 01       	movw	r30, r16
    1c5a:	80 83       	st	Z, r24
    1c5c:	91 83       	std	Z+1, r25	; 0x01
    1c5e:	a2 83       	std	Z+2, r26	; 0x02
    1c60:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1c62:	fe 01       	movw	r30, r28
    1c64:	e5 5a       	subi	r30, 0xA5	; 165
    1c66:	ff 4f       	sbci	r31, 0xFF	; 255
    1c68:	60 81       	ld	r22, Z
    1c6a:	71 81       	ldd	r23, Z+1	; 0x01
    1c6c:	82 81       	ldd	r24, Z+2	; 0x02
    1c6e:	93 81       	ldd	r25, Z+3	; 0x03
    1c70:	20 e0       	ldi	r18, 0x00	; 0
    1c72:	30 e0       	ldi	r19, 0x00	; 0
    1c74:	40 e8       	ldi	r20, 0x80	; 128
    1c76:	5f e3       	ldi	r21, 0x3F	; 63
    1c78:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c7c:	88 23       	and	r24, r24
    1c7e:	44 f4       	brge	.+16     	; 0x1c90 <systemSettings+0xb0>
		__ticks = 1;
    1c80:	fe 01       	movw	r30, r28
    1c82:	e7 5a       	subi	r30, 0xA7	; 167
    1c84:	ff 4f       	sbci	r31, 0xFF	; 255
    1c86:	81 e0       	ldi	r24, 0x01	; 1
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	91 83       	std	Z+1, r25	; 0x01
    1c8c:	80 83       	st	Z, r24
    1c8e:	64 c0       	rjmp	.+200    	; 0x1d58 <systemSettings+0x178>
	else if (__tmp > 65535)
    1c90:	fe 01       	movw	r30, r28
    1c92:	e5 5a       	subi	r30, 0xA5	; 165
    1c94:	ff 4f       	sbci	r31, 0xFF	; 255
    1c96:	60 81       	ld	r22, Z
    1c98:	71 81       	ldd	r23, Z+1	; 0x01
    1c9a:	82 81       	ldd	r24, Z+2	; 0x02
    1c9c:	93 81       	ldd	r25, Z+3	; 0x03
    1c9e:	20 e0       	ldi	r18, 0x00	; 0
    1ca0:	3f ef       	ldi	r19, 0xFF	; 255
    1ca2:	4f e7       	ldi	r20, 0x7F	; 127
    1ca4:	57 e4       	ldi	r21, 0x47	; 71
    1ca6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1caa:	18 16       	cp	r1, r24
    1cac:	0c f0       	brlt	.+2      	; 0x1cb0 <systemSettings+0xd0>
    1cae:	43 c0       	rjmp	.+134    	; 0x1d36 <systemSettings+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cb0:	fe 01       	movw	r30, r28
    1cb2:	e1 5a       	subi	r30, 0xA1	; 161
    1cb4:	ff 4f       	sbci	r31, 0xFF	; 255
    1cb6:	60 81       	ld	r22, Z
    1cb8:	71 81       	ldd	r23, Z+1	; 0x01
    1cba:	82 81       	ldd	r24, Z+2	; 0x02
    1cbc:	93 81       	ldd	r25, Z+3	; 0x03
    1cbe:	20 e0       	ldi	r18, 0x00	; 0
    1cc0:	30 e0       	ldi	r19, 0x00	; 0
    1cc2:	40 e2       	ldi	r20, 0x20	; 32
    1cc4:	51 e4       	ldi	r21, 0x41	; 65
    1cc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cca:	dc 01       	movw	r26, r24
    1ccc:	cb 01       	movw	r24, r22
    1cce:	8e 01       	movw	r16, r28
    1cd0:	07 5a       	subi	r16, 0xA7	; 167
    1cd2:	1f 4f       	sbci	r17, 0xFF	; 255
    1cd4:	bc 01       	movw	r22, r24
    1cd6:	cd 01       	movw	r24, r26
    1cd8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cdc:	dc 01       	movw	r26, r24
    1cde:	cb 01       	movw	r24, r22
    1ce0:	f8 01       	movw	r30, r16
    1ce2:	91 83       	std	Z+1, r25	; 0x01
    1ce4:	80 83       	st	Z, r24
    1ce6:	1f c0       	rjmp	.+62     	; 0x1d26 <systemSettings+0x146>
    1ce8:	fe 01       	movw	r30, r28
    1cea:	e9 5a       	subi	r30, 0xA9	; 169
    1cec:	ff 4f       	sbci	r31, 0xFF	; 255
    1cee:	89 e1       	ldi	r24, 0x19	; 25
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	91 83       	std	Z+1, r25	; 0x01
    1cf4:	80 83       	st	Z, r24
    1cf6:	fe 01       	movw	r30, r28
    1cf8:	e9 5a       	subi	r30, 0xA9	; 169
    1cfa:	ff 4f       	sbci	r31, 0xFF	; 255
    1cfc:	80 81       	ld	r24, Z
    1cfe:	91 81       	ldd	r25, Z+1	; 0x01
    1d00:	01 97       	sbiw	r24, 0x01	; 1
    1d02:	f1 f7       	brne	.-4      	; 0x1d00 <systemSettings+0x120>
    1d04:	fe 01       	movw	r30, r28
    1d06:	e9 5a       	subi	r30, 0xA9	; 169
    1d08:	ff 4f       	sbci	r31, 0xFF	; 255
    1d0a:	91 83       	std	Z+1, r25	; 0x01
    1d0c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d0e:	de 01       	movw	r26, r28
    1d10:	a7 5a       	subi	r26, 0xA7	; 167
    1d12:	bf 4f       	sbci	r27, 0xFF	; 255
    1d14:	fe 01       	movw	r30, r28
    1d16:	e7 5a       	subi	r30, 0xA7	; 167
    1d18:	ff 4f       	sbci	r31, 0xFF	; 255
    1d1a:	80 81       	ld	r24, Z
    1d1c:	91 81       	ldd	r25, Z+1	; 0x01
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	11 96       	adiw	r26, 0x01	; 1
    1d22:	9c 93       	st	X, r25
    1d24:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d26:	fe 01       	movw	r30, r28
    1d28:	e7 5a       	subi	r30, 0xA7	; 167
    1d2a:	ff 4f       	sbci	r31, 0xFF	; 255
    1d2c:	80 81       	ld	r24, Z
    1d2e:	91 81       	ldd	r25, Z+1	; 0x01
    1d30:	00 97       	sbiw	r24, 0x00	; 0
    1d32:	d1 f6       	brne	.-76     	; 0x1ce8 <systemSettings+0x108>
    1d34:	27 c0       	rjmp	.+78     	; 0x1d84 <systemSettings+0x1a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d36:	8e 01       	movw	r16, r28
    1d38:	07 5a       	subi	r16, 0xA7	; 167
    1d3a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d3c:	fe 01       	movw	r30, r28
    1d3e:	e5 5a       	subi	r30, 0xA5	; 165
    1d40:	ff 4f       	sbci	r31, 0xFF	; 255
    1d42:	60 81       	ld	r22, Z
    1d44:	71 81       	ldd	r23, Z+1	; 0x01
    1d46:	82 81       	ldd	r24, Z+2	; 0x02
    1d48:	93 81       	ldd	r25, Z+3	; 0x03
    1d4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d4e:	dc 01       	movw	r26, r24
    1d50:	cb 01       	movw	r24, r22
    1d52:	f8 01       	movw	r30, r16
    1d54:	91 83       	std	Z+1, r25	; 0x01
    1d56:	80 83       	st	Z, r24
    1d58:	de 01       	movw	r26, r28
    1d5a:	ab 5a       	subi	r26, 0xAB	; 171
    1d5c:	bf 4f       	sbci	r27, 0xFF	; 255
    1d5e:	fe 01       	movw	r30, r28
    1d60:	e7 5a       	subi	r30, 0xA7	; 167
    1d62:	ff 4f       	sbci	r31, 0xFF	; 255
    1d64:	80 81       	ld	r24, Z
    1d66:	91 81       	ldd	r25, Z+1	; 0x01
    1d68:	8d 93       	st	X+, r24
    1d6a:	9c 93       	st	X, r25
    1d6c:	fe 01       	movw	r30, r28
    1d6e:	eb 5a       	subi	r30, 0xAB	; 171
    1d70:	ff 4f       	sbci	r31, 0xFF	; 255
    1d72:	80 81       	ld	r24, Z
    1d74:	91 81       	ldd	r25, Z+1	; 0x01
    1d76:	01 97       	sbiw	r24, 0x01	; 1
    1d78:	f1 f7       	brne	.-4      	; 0x1d76 <systemSettings+0x196>
    1d7a:	fe 01       	movw	r30, r28
    1d7c:	eb 5a       	subi	r30, 0xAB	; 171
    1d7e:	ff 4f       	sbci	r31, 0xFF	; 255
    1d80:	91 83       	std	Z+1, r25	; 0x01
    1d82:	80 83       	st	Z, r24
	_delay_ms(800);
	LCD_clearScreen();
    1d84:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
	LCD_displayString("Change password ");
    1d88:	8a ec       	ldi	r24, 0xCA	; 202
    1d8a:	90 e0       	ldi	r25, 0x00	; 0
    1d8c:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
	LCD_goToRowColumn(1 ,0);
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	60 e0       	ldi	r22, 0x00	; 0
    1d94:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <LCD_goToRowColumn>
	LCD_displayString("(press + )");
    1d98:	8b ed       	ldi	r24, 0xDB	; 219
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    1da0:	fe 01       	movw	r30, r28
    1da2:	ef 5a       	subi	r30, 0xAF	; 175
    1da4:	ff 4f       	sbci	r31, 0xFF	; 255
    1da6:	80 e0       	ldi	r24, 0x00	; 0
    1da8:	90 e0       	ldi	r25, 0x00	; 0
    1daa:	a8 e4       	ldi	r26, 0x48	; 72
    1dac:	b4 e4       	ldi	r27, 0x44	; 68
    1dae:	80 83       	st	Z, r24
    1db0:	91 83       	std	Z+1, r25	; 0x01
    1db2:	a2 83       	std	Z+2, r26	; 0x02
    1db4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1db6:	8e 01       	movw	r16, r28
    1db8:	03 5b       	subi	r16, 0xB3	; 179
    1dba:	1f 4f       	sbci	r17, 0xFF	; 255
    1dbc:	fe 01       	movw	r30, r28
    1dbe:	ef 5a       	subi	r30, 0xAF	; 175
    1dc0:	ff 4f       	sbci	r31, 0xFF	; 255
    1dc2:	60 81       	ld	r22, Z
    1dc4:	71 81       	ldd	r23, Z+1	; 0x01
    1dc6:	82 81       	ldd	r24, Z+2	; 0x02
    1dc8:	93 81       	ldd	r25, Z+3	; 0x03
    1dca:	20 e0       	ldi	r18, 0x00	; 0
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	4a e7       	ldi	r20, 0x7A	; 122
    1dd0:	53 e4       	ldi	r21, 0x43	; 67
    1dd2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dd6:	dc 01       	movw	r26, r24
    1dd8:	cb 01       	movw	r24, r22
    1dda:	f8 01       	movw	r30, r16
    1ddc:	80 83       	st	Z, r24
    1dde:	91 83       	std	Z+1, r25	; 0x01
    1de0:	a2 83       	std	Z+2, r26	; 0x02
    1de2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1de4:	fe 01       	movw	r30, r28
    1de6:	e3 5b       	subi	r30, 0xB3	; 179
    1de8:	ff 4f       	sbci	r31, 0xFF	; 255
    1dea:	60 81       	ld	r22, Z
    1dec:	71 81       	ldd	r23, Z+1	; 0x01
    1dee:	82 81       	ldd	r24, Z+2	; 0x02
    1df0:	93 81       	ldd	r25, Z+3	; 0x03
    1df2:	20 e0       	ldi	r18, 0x00	; 0
    1df4:	30 e0       	ldi	r19, 0x00	; 0
    1df6:	40 e8       	ldi	r20, 0x80	; 128
    1df8:	5f e3       	ldi	r21, 0x3F	; 63
    1dfa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1dfe:	88 23       	and	r24, r24
    1e00:	44 f4       	brge	.+16     	; 0x1e12 <systemSettings+0x232>
		__ticks = 1;
    1e02:	fe 01       	movw	r30, r28
    1e04:	e5 5b       	subi	r30, 0xB5	; 181
    1e06:	ff 4f       	sbci	r31, 0xFF	; 255
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	90 e0       	ldi	r25, 0x00	; 0
    1e0c:	91 83       	std	Z+1, r25	; 0x01
    1e0e:	80 83       	st	Z, r24
    1e10:	64 c0       	rjmp	.+200    	; 0x1eda <systemSettings+0x2fa>
	else if (__tmp > 65535)
    1e12:	fe 01       	movw	r30, r28
    1e14:	e3 5b       	subi	r30, 0xB3	; 179
    1e16:	ff 4f       	sbci	r31, 0xFF	; 255
    1e18:	60 81       	ld	r22, Z
    1e1a:	71 81       	ldd	r23, Z+1	; 0x01
    1e1c:	82 81       	ldd	r24, Z+2	; 0x02
    1e1e:	93 81       	ldd	r25, Z+3	; 0x03
    1e20:	20 e0       	ldi	r18, 0x00	; 0
    1e22:	3f ef       	ldi	r19, 0xFF	; 255
    1e24:	4f e7       	ldi	r20, 0x7F	; 127
    1e26:	57 e4       	ldi	r21, 0x47	; 71
    1e28:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1e2c:	18 16       	cp	r1, r24
    1e2e:	0c f0       	brlt	.+2      	; 0x1e32 <systemSettings+0x252>
    1e30:	43 c0       	rjmp	.+134    	; 0x1eb8 <systemSettings+0x2d8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e32:	fe 01       	movw	r30, r28
    1e34:	ef 5a       	subi	r30, 0xAF	; 175
    1e36:	ff 4f       	sbci	r31, 0xFF	; 255
    1e38:	60 81       	ld	r22, Z
    1e3a:	71 81       	ldd	r23, Z+1	; 0x01
    1e3c:	82 81       	ldd	r24, Z+2	; 0x02
    1e3e:	93 81       	ldd	r25, Z+3	; 0x03
    1e40:	20 e0       	ldi	r18, 0x00	; 0
    1e42:	30 e0       	ldi	r19, 0x00	; 0
    1e44:	40 e2       	ldi	r20, 0x20	; 32
    1e46:	51 e4       	ldi	r21, 0x41	; 65
    1e48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e4c:	dc 01       	movw	r26, r24
    1e4e:	cb 01       	movw	r24, r22
    1e50:	8e 01       	movw	r16, r28
    1e52:	05 5b       	subi	r16, 0xB5	; 181
    1e54:	1f 4f       	sbci	r17, 0xFF	; 255
    1e56:	bc 01       	movw	r22, r24
    1e58:	cd 01       	movw	r24, r26
    1e5a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e5e:	dc 01       	movw	r26, r24
    1e60:	cb 01       	movw	r24, r22
    1e62:	f8 01       	movw	r30, r16
    1e64:	91 83       	std	Z+1, r25	; 0x01
    1e66:	80 83       	st	Z, r24
    1e68:	1f c0       	rjmp	.+62     	; 0x1ea8 <systemSettings+0x2c8>
    1e6a:	fe 01       	movw	r30, r28
    1e6c:	e7 5b       	subi	r30, 0xB7	; 183
    1e6e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e70:	89 e1       	ldi	r24, 0x19	; 25
    1e72:	90 e0       	ldi	r25, 0x00	; 0
    1e74:	91 83       	std	Z+1, r25	; 0x01
    1e76:	80 83       	st	Z, r24
    1e78:	fe 01       	movw	r30, r28
    1e7a:	e7 5b       	subi	r30, 0xB7	; 183
    1e7c:	ff 4f       	sbci	r31, 0xFF	; 255
    1e7e:	80 81       	ld	r24, Z
    1e80:	91 81       	ldd	r25, Z+1	; 0x01
    1e82:	01 97       	sbiw	r24, 0x01	; 1
    1e84:	f1 f7       	brne	.-4      	; 0x1e82 <systemSettings+0x2a2>
    1e86:	fe 01       	movw	r30, r28
    1e88:	e7 5b       	subi	r30, 0xB7	; 183
    1e8a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e8c:	91 83       	std	Z+1, r25	; 0x01
    1e8e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e90:	de 01       	movw	r26, r28
    1e92:	a5 5b       	subi	r26, 0xB5	; 181
    1e94:	bf 4f       	sbci	r27, 0xFF	; 255
    1e96:	fe 01       	movw	r30, r28
    1e98:	e5 5b       	subi	r30, 0xB5	; 181
    1e9a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e9c:	80 81       	ld	r24, Z
    1e9e:	91 81       	ldd	r25, Z+1	; 0x01
    1ea0:	01 97       	sbiw	r24, 0x01	; 1
    1ea2:	11 96       	adiw	r26, 0x01	; 1
    1ea4:	9c 93       	st	X, r25
    1ea6:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ea8:	fe 01       	movw	r30, r28
    1eaa:	e5 5b       	subi	r30, 0xB5	; 181
    1eac:	ff 4f       	sbci	r31, 0xFF	; 255
    1eae:	80 81       	ld	r24, Z
    1eb0:	91 81       	ldd	r25, Z+1	; 0x01
    1eb2:	00 97       	sbiw	r24, 0x00	; 0
    1eb4:	d1 f6       	brne	.-76     	; 0x1e6a <systemSettings+0x28a>
    1eb6:	27 c0       	rjmp	.+78     	; 0x1f06 <systemSettings+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1eb8:	8e 01       	movw	r16, r28
    1eba:	05 5b       	subi	r16, 0xB5	; 181
    1ebc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ebe:	fe 01       	movw	r30, r28
    1ec0:	e3 5b       	subi	r30, 0xB3	; 179
    1ec2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ec4:	60 81       	ld	r22, Z
    1ec6:	71 81       	ldd	r23, Z+1	; 0x01
    1ec8:	82 81       	ldd	r24, Z+2	; 0x02
    1eca:	93 81       	ldd	r25, Z+3	; 0x03
    1ecc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ed0:	dc 01       	movw	r26, r24
    1ed2:	cb 01       	movw	r24, r22
    1ed4:	f8 01       	movw	r30, r16
    1ed6:	91 83       	std	Z+1, r25	; 0x01
    1ed8:	80 83       	st	Z, r24
    1eda:	de 01       	movw	r26, r28
    1edc:	a9 5b       	subi	r26, 0xB9	; 185
    1ede:	bf 4f       	sbci	r27, 0xFF	; 255
    1ee0:	fe 01       	movw	r30, r28
    1ee2:	e5 5b       	subi	r30, 0xB5	; 181
    1ee4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ee6:	80 81       	ld	r24, Z
    1ee8:	91 81       	ldd	r25, Z+1	; 0x01
    1eea:	8d 93       	st	X+, r24
    1eec:	9c 93       	st	X, r25
    1eee:	fe 01       	movw	r30, r28
    1ef0:	e9 5b       	subi	r30, 0xB9	; 185
    1ef2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ef4:	80 81       	ld	r24, Z
    1ef6:	91 81       	ldd	r25, Z+1	; 0x01
    1ef8:	01 97       	sbiw	r24, 0x01	; 1
    1efa:	f1 f7       	brne	.-4      	; 0x1ef8 <systemSettings+0x318>
    1efc:	fe 01       	movw	r30, r28
    1efe:	e9 5b       	subi	r30, 0xB9	; 185
    1f00:	ff 4f       	sbci	r31, 0xFF	; 255
    1f02:	91 83       	std	Z+1, r25	; 0x01
    1f04:	80 83       	st	Z, r24
	_delay_ms(800);

	if (KeyPad_getPressedKey()== '*') /* open the door */
    1f06:	0e 94 a3 05 	call	0xb46	; 0xb46 <KeyPad_getPressedKey>
    1f0a:	8a 32       	cpi	r24, 0x2A	; 42
    1f0c:	09 f0       	breq	.+2      	; 0x1f10 <systemSettings+0x330>
    1f0e:	5e c1       	rjmp	.+700    	; 0x21cc <systemSettings+0x5ec>
	{
			LCD_clearScreen();
    1f10:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
			USART_sendByte(OPEN_DOOR_REQ); /* send msg to MC2 to can understand that it will receive the old password from MC2 */
    1f14:	8d e0       	ldi	r24, 0x0D	; 13
    1f16:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>
			USART_receiveString(oldPassword); /* uart  receive the old password from MC2 to compare it with current password */
    1f1a:	ce 01       	movw	r24, r28
    1f1c:	84 59       	subi	r24, 0x94	; 148
    1f1e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f20:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <USART_receiveString>
			while (1)
			{
				LCD_clearScreen();
    1f24:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
				LCD_displayString("enter password");
    1f28:	86 ee       	ldi	r24, 0xE6	; 230
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    1f30:	fe 01       	movw	r30, r28
    1f32:	ed 5b       	subi	r30, 0xBD	; 189
    1f34:	ff 4f       	sbci	r31, 0xFF	; 255
    1f36:	80 e0       	ldi	r24, 0x00	; 0
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	aa e7       	ldi	r26, 0x7A	; 122
    1f3c:	b4 e4       	ldi	r27, 0x44	; 68
    1f3e:	80 83       	st	Z, r24
    1f40:	91 83       	std	Z+1, r25	; 0x01
    1f42:	a2 83       	std	Z+2, r26	; 0x02
    1f44:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f46:	8e 01       	movw	r16, r28
    1f48:	01 5c       	subi	r16, 0xC1	; 193
    1f4a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f4c:	fe 01       	movw	r30, r28
    1f4e:	ed 5b       	subi	r30, 0xBD	; 189
    1f50:	ff 4f       	sbci	r31, 0xFF	; 255
    1f52:	60 81       	ld	r22, Z
    1f54:	71 81       	ldd	r23, Z+1	; 0x01
    1f56:	82 81       	ldd	r24, Z+2	; 0x02
    1f58:	93 81       	ldd	r25, Z+3	; 0x03
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	30 e0       	ldi	r19, 0x00	; 0
    1f5e:	4a e7       	ldi	r20, 0x7A	; 122
    1f60:	53 e4       	ldi	r21, 0x43	; 67
    1f62:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f66:	dc 01       	movw	r26, r24
    1f68:	cb 01       	movw	r24, r22
    1f6a:	f8 01       	movw	r30, r16
    1f6c:	80 83       	st	Z, r24
    1f6e:	91 83       	std	Z+1, r25	; 0x01
    1f70:	a2 83       	std	Z+2, r26	; 0x02
    1f72:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1f74:	fe 01       	movw	r30, r28
    1f76:	ff 96       	adiw	r30, 0x3f	; 63
    1f78:	60 81       	ld	r22, Z
    1f7a:	71 81       	ldd	r23, Z+1	; 0x01
    1f7c:	82 81       	ldd	r24, Z+2	; 0x02
    1f7e:	93 81       	ldd	r25, Z+3	; 0x03
    1f80:	20 e0       	ldi	r18, 0x00	; 0
    1f82:	30 e0       	ldi	r19, 0x00	; 0
    1f84:	40 e8       	ldi	r20, 0x80	; 128
    1f86:	5f e3       	ldi	r21, 0x3F	; 63
    1f88:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1f8c:	88 23       	and	r24, r24
    1f8e:	2c f4       	brge	.+10     	; 0x1f9a <systemSettings+0x3ba>
		__ticks = 1;
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	9e af       	std	Y+62, r25	; 0x3e
    1f96:	8d af       	std	Y+61, r24	; 0x3d
    1f98:	46 c0       	rjmp	.+140    	; 0x2026 <systemSettings+0x446>
	else if (__tmp > 65535)
    1f9a:	fe 01       	movw	r30, r28
    1f9c:	ff 96       	adiw	r30, 0x3f	; 63
    1f9e:	60 81       	ld	r22, Z
    1fa0:	71 81       	ldd	r23, Z+1	; 0x01
    1fa2:	82 81       	ldd	r24, Z+2	; 0x02
    1fa4:	93 81       	ldd	r25, Z+3	; 0x03
    1fa6:	20 e0       	ldi	r18, 0x00	; 0
    1fa8:	3f ef       	ldi	r19, 0xFF	; 255
    1faa:	4f e7       	ldi	r20, 0x7F	; 127
    1fac:	57 e4       	ldi	r21, 0x47	; 71
    1fae:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1fb2:	18 16       	cp	r1, r24
    1fb4:	64 f5       	brge	.+88     	; 0x200e <systemSettings+0x42e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fb6:	fe 01       	movw	r30, r28
    1fb8:	ed 5b       	subi	r30, 0xBD	; 189
    1fba:	ff 4f       	sbci	r31, 0xFF	; 255
    1fbc:	60 81       	ld	r22, Z
    1fbe:	71 81       	ldd	r23, Z+1	; 0x01
    1fc0:	82 81       	ldd	r24, Z+2	; 0x02
    1fc2:	93 81       	ldd	r25, Z+3	; 0x03
    1fc4:	20 e0       	ldi	r18, 0x00	; 0
    1fc6:	30 e0       	ldi	r19, 0x00	; 0
    1fc8:	40 e2       	ldi	r20, 0x20	; 32
    1fca:	51 e4       	ldi	r21, 0x41	; 65
    1fcc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fd0:	dc 01       	movw	r26, r24
    1fd2:	cb 01       	movw	r24, r22
    1fd4:	bc 01       	movw	r22, r24
    1fd6:	cd 01       	movw	r24, r26
    1fd8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fdc:	dc 01       	movw	r26, r24
    1fde:	cb 01       	movw	r24, r22
    1fe0:	9e af       	std	Y+62, r25	; 0x3e
    1fe2:	8d af       	std	Y+61, r24	; 0x3d
    1fe4:	0f c0       	rjmp	.+30     	; 0x2004 <systemSettings+0x424>
    1fe6:	89 e1       	ldi	r24, 0x19	; 25
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	9c af       	std	Y+60, r25	; 0x3c
    1fec:	8b af       	std	Y+59, r24	; 0x3b
    1fee:	8b ad       	ldd	r24, Y+59	; 0x3b
    1ff0:	9c ad       	ldd	r25, Y+60	; 0x3c
    1ff2:	01 97       	sbiw	r24, 0x01	; 1
    1ff4:	f1 f7       	brne	.-4      	; 0x1ff2 <systemSettings+0x412>
    1ff6:	9c af       	std	Y+60, r25	; 0x3c
    1ff8:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ffa:	8d ad       	ldd	r24, Y+61	; 0x3d
    1ffc:	9e ad       	ldd	r25, Y+62	; 0x3e
    1ffe:	01 97       	sbiw	r24, 0x01	; 1
    2000:	9e af       	std	Y+62, r25	; 0x3e
    2002:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2004:	8d ad       	ldd	r24, Y+61	; 0x3d
    2006:	9e ad       	ldd	r25, Y+62	; 0x3e
    2008:	00 97       	sbiw	r24, 0x00	; 0
    200a:	69 f7       	brne	.-38     	; 0x1fe6 <systemSettings+0x406>
    200c:	16 c0       	rjmp	.+44     	; 0x203a <systemSettings+0x45a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    200e:	fe 01       	movw	r30, r28
    2010:	ff 96       	adiw	r30, 0x3f	; 63
    2012:	60 81       	ld	r22, Z
    2014:	71 81       	ldd	r23, Z+1	; 0x01
    2016:	82 81       	ldd	r24, Z+2	; 0x02
    2018:	93 81       	ldd	r25, Z+3	; 0x03
    201a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    201e:	dc 01       	movw	r26, r24
    2020:	cb 01       	movw	r24, r22
    2022:	9e af       	std	Y+62, r25	; 0x3e
    2024:	8d af       	std	Y+61, r24	; 0x3d
    2026:	8d ad       	ldd	r24, Y+61	; 0x3d
    2028:	9e ad       	ldd	r25, Y+62	; 0x3e
    202a:	9a af       	std	Y+58, r25	; 0x3a
    202c:	89 af       	std	Y+57, r24	; 0x39
    202e:	89 ad       	ldd	r24, Y+57	; 0x39
    2030:	9a ad       	ldd	r25, Y+58	; 0x3a
    2032:	01 97       	sbiw	r24, 0x01	; 1
    2034:	f1 f7       	brne	.-4      	; 0x2032 <systemSettings+0x452>
    2036:	9a af       	std	Y+58, r25	; 0x3a
    2038:	89 af       	std	Y+57, r24	; 0x39
				_delay_ms(1000);
				LCD_clearScreen();
    203a:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
				enterPassword(&passwordCode);
    203e:	ce 01       	movw	r24, r28
    2040:	8a 59       	subi	r24, 0x9A	; 154
    2042:	9f 4f       	sbci	r25, 0xFF	; 255
    2044:	0e 94 b6 12 	call	0x256c	; 0x256c <enterPassword>
				if(count ==2)
    2048:	fe 01       	movw	r30, r28
    204a:	eb 59       	subi	r30, 0x9B	; 155
    204c:	ff 4f       	sbci	r31, 0xFF	; 255
    204e:	80 81       	ld	r24, Z
    2050:	82 30       	cpi	r24, 0x02	; 2
    2052:	b1 f4       	brne	.+44     	; 0x2080 <systemSettings+0x4a0>
				{
					LCD_clearScreen();
    2054:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
					LCD_displayString("Exceed 3 times");
    2058:	85 ef       	ldi	r24, 0xF5	; 245
    205a:	90 e0       	ldi	r25, 0x00	; 0
    205c:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
					/* send msg to MC2 to can understand that it will turn on buzzer because the password is entered wrong 3 times */
					USART_sendByte(WRONG_PASSWORD);
    2060:	8f e0       	ldi	r24, 0x0F	; 15
    2062:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>

					/* recieve finising bit when the buzzer finished its work */
					uint8 buzzerOff =USART_recieveByte();
    2066:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <USART_recieveByte>
    206a:	fe 01       	movw	r30, r28
    206c:	ec 59       	subi	r30, 0x9C	; 156
    206e:	ff 4f       	sbci	r31, 0xFF	; 255
    2070:	80 83       	st	Z, r24
					if(buzzerOff == BUZZER_OFF)
    2072:	fe 01       	movw	r30, r28
    2074:	ec 59       	subi	r30, 0x9C	; 156
    2076:	ff 4f       	sbci	r31, 0xFF	; 255
    2078:	80 81       	ld	r24, Z
    207a:	83 30       	cpi	r24, 0x03	; 3
    207c:	09 f4       	brne	.+2      	; 0x2080 <systemSettings+0x4a0>
    207e:	6a c2       	rjmp	.+1236   	; 0x2554 <systemSettings+0x974>
						_delay_ms(60000); // delay for 1 min util buzzer finish
						break;
					 ************************************************/

				}
				if(strcmp(passwordCode , oldPassword)==0 && count <2)
    2080:	ce 01       	movw	r24, r28
    2082:	8a 59       	subi	r24, 0x9A	; 154
    2084:	9f 4f       	sbci	r25, 0xFF	; 255
    2086:	9e 01       	movw	r18, r28
    2088:	24 59       	subi	r18, 0x94	; 148
    208a:	3f 4f       	sbci	r19, 0xFF	; 255
    208c:	b9 01       	movw	r22, r18
    208e:	0e 94 0f 18 	call	0x301e	; 0x301e <strcmp>
    2092:	00 97       	sbiw	r24, 0x00	; 0
    2094:	c9 f4       	brne	.+50     	; 0x20c8 <systemSettings+0x4e8>
    2096:	fe 01       	movw	r30, r28
    2098:	eb 59       	subi	r30, 0x9B	; 155
    209a:	ff 4f       	sbci	r31, 0xFF	; 255
    209c:	80 81       	ld	r24, Z
    209e:	82 30       	cpi	r24, 0x02	; 2
    20a0:	98 f4       	brcc	.+38     	; 0x20c8 <systemSettings+0x4e8>
				{
					count=0;
    20a2:	fe 01       	movw	r30, r28
    20a4:	eb 59       	subi	r30, 0x9B	; 155
    20a6:	ff 4f       	sbci	r31, 0xFF	; 255
    20a8:	10 82       	st	Z, r1

					USART_sendByte(OPEN_DOOR); /* send msg to MC2 to can understand that it will open the door */
    20aa:	8e e0       	ldi	r24, 0x0E	; 14
    20ac:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>

					//LCD_clearScreen();
					//LCD_displayString("open door");
					LCD_clearScreen();
    20b0:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
					LCD_displayString("Door is opening");
    20b4:	84 e0       	ldi	r24, 0x04	; 4
    20b6:	91 e0       	ldi	r25, 0x01	; 1
    20b8:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
					//_delay_ms(1000);
					/* prepare timer to display on lcd door unlocking for 15s when the door open by dc motor for 15s,then display on lcd door locking for 15s when the door close by dc motor for 15s */
					openingMsgFlag =1;
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	80 93 4c 01 	sts	0x014C, r24
					prepareTimer();
    20c2:	0e 94 ce 13 	call	0x279c	; 0x279c <prepareTimer>
    20c6:	46 c2       	rjmp	.+1164   	; 0x2554 <systemSettings+0x974>

					break;
				}
				count++;
    20c8:	de 01       	movw	r26, r28
    20ca:	ab 59       	subi	r26, 0x9B	; 155
    20cc:	bf 4f       	sbci	r27, 0xFF	; 255
    20ce:	fe 01       	movw	r30, r28
    20d0:	eb 59       	subi	r30, 0x9B	; 155
    20d2:	ff 4f       	sbci	r31, 0xFF	; 255
    20d4:	80 81       	ld	r24, Z
    20d6:	8f 5f       	subi	r24, 0xFF	; 255
    20d8:	8c 93       	st	X, r24
				LCD_clearScreen();
    20da:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
				LCD_displayString("invalid match");
    20de:	82 ea       	ldi	r24, 0xA2	; 162
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    20e6:	80 e0       	ldi	r24, 0x00	; 0
    20e8:	90 e0       	ldi	r25, 0x00	; 0
    20ea:	aa ef       	ldi	r26, 0xFA	; 250
    20ec:	b3 e4       	ldi	r27, 0x43	; 67
    20ee:	8d ab       	std	Y+53, r24	; 0x35
    20f0:	9e ab       	std	Y+54, r25	; 0x36
    20f2:	af ab       	std	Y+55, r26	; 0x37
    20f4:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20f6:	6d a9       	ldd	r22, Y+53	; 0x35
    20f8:	7e a9       	ldd	r23, Y+54	; 0x36
    20fa:	8f a9       	ldd	r24, Y+55	; 0x37
    20fc:	98 ad       	ldd	r25, Y+56	; 0x38
    20fe:	20 e0       	ldi	r18, 0x00	; 0
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	4a e7       	ldi	r20, 0x7A	; 122
    2104:	53 e4       	ldi	r21, 0x43	; 67
    2106:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    210a:	dc 01       	movw	r26, r24
    210c:	cb 01       	movw	r24, r22
    210e:	89 ab       	std	Y+49, r24	; 0x31
    2110:	9a ab       	std	Y+50, r25	; 0x32
    2112:	ab ab       	std	Y+51, r26	; 0x33
    2114:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2116:	69 a9       	ldd	r22, Y+49	; 0x31
    2118:	7a a9       	ldd	r23, Y+50	; 0x32
    211a:	8b a9       	ldd	r24, Y+51	; 0x33
    211c:	9c a9       	ldd	r25, Y+52	; 0x34
    211e:	20 e0       	ldi	r18, 0x00	; 0
    2120:	30 e0       	ldi	r19, 0x00	; 0
    2122:	40 e8       	ldi	r20, 0x80	; 128
    2124:	5f e3       	ldi	r21, 0x3F	; 63
    2126:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    212a:	88 23       	and	r24, r24
    212c:	2c f4       	brge	.+10     	; 0x2138 <systemSettings+0x558>
		__ticks = 1;
    212e:	81 e0       	ldi	r24, 0x01	; 1
    2130:	90 e0       	ldi	r25, 0x00	; 0
    2132:	98 ab       	std	Y+48, r25	; 0x30
    2134:	8f a7       	std	Y+47, r24	; 0x2f
    2136:	3f c0       	rjmp	.+126    	; 0x21b6 <systemSettings+0x5d6>
	else if (__tmp > 65535)
    2138:	69 a9       	ldd	r22, Y+49	; 0x31
    213a:	7a a9       	ldd	r23, Y+50	; 0x32
    213c:	8b a9       	ldd	r24, Y+51	; 0x33
    213e:	9c a9       	ldd	r25, Y+52	; 0x34
    2140:	20 e0       	ldi	r18, 0x00	; 0
    2142:	3f ef       	ldi	r19, 0xFF	; 255
    2144:	4f e7       	ldi	r20, 0x7F	; 127
    2146:	57 e4       	ldi	r21, 0x47	; 71
    2148:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    214c:	18 16       	cp	r1, r24
    214e:	4c f5       	brge	.+82     	; 0x21a2 <systemSettings+0x5c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2150:	6d a9       	ldd	r22, Y+53	; 0x35
    2152:	7e a9       	ldd	r23, Y+54	; 0x36
    2154:	8f a9       	ldd	r24, Y+55	; 0x37
    2156:	98 ad       	ldd	r25, Y+56	; 0x38
    2158:	20 e0       	ldi	r18, 0x00	; 0
    215a:	30 e0       	ldi	r19, 0x00	; 0
    215c:	40 e2       	ldi	r20, 0x20	; 32
    215e:	51 e4       	ldi	r21, 0x41	; 65
    2160:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2164:	dc 01       	movw	r26, r24
    2166:	cb 01       	movw	r24, r22
    2168:	bc 01       	movw	r22, r24
    216a:	cd 01       	movw	r24, r26
    216c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2170:	dc 01       	movw	r26, r24
    2172:	cb 01       	movw	r24, r22
    2174:	98 ab       	std	Y+48, r25	; 0x30
    2176:	8f a7       	std	Y+47, r24	; 0x2f
    2178:	0f c0       	rjmp	.+30     	; 0x2198 <systemSettings+0x5b8>
    217a:	89 e1       	ldi	r24, 0x19	; 25
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	9e a7       	std	Y+46, r25	; 0x2e
    2180:	8d a7       	std	Y+45, r24	; 0x2d
    2182:	8d a5       	ldd	r24, Y+45	; 0x2d
    2184:	9e a5       	ldd	r25, Y+46	; 0x2e
    2186:	01 97       	sbiw	r24, 0x01	; 1
    2188:	f1 f7       	brne	.-4      	; 0x2186 <systemSettings+0x5a6>
    218a:	9e a7       	std	Y+46, r25	; 0x2e
    218c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    218e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2190:	98 a9       	ldd	r25, Y+48	; 0x30
    2192:	01 97       	sbiw	r24, 0x01	; 1
    2194:	98 ab       	std	Y+48, r25	; 0x30
    2196:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2198:	8f a5       	ldd	r24, Y+47	; 0x2f
    219a:	98 a9       	ldd	r25, Y+48	; 0x30
    219c:	00 97       	sbiw	r24, 0x00	; 0
    219e:	69 f7       	brne	.-38     	; 0x217a <systemSettings+0x59a>
    21a0:	c1 ce       	rjmp	.-638    	; 0x1f24 <systemSettings+0x344>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21a2:	69 a9       	ldd	r22, Y+49	; 0x31
    21a4:	7a a9       	ldd	r23, Y+50	; 0x32
    21a6:	8b a9       	ldd	r24, Y+51	; 0x33
    21a8:	9c a9       	ldd	r25, Y+52	; 0x34
    21aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21ae:	dc 01       	movw	r26, r24
    21b0:	cb 01       	movw	r24, r22
    21b2:	98 ab       	std	Y+48, r25	; 0x30
    21b4:	8f a7       	std	Y+47, r24	; 0x2f
    21b6:	8f a5       	ldd	r24, Y+47	; 0x2f
    21b8:	98 a9       	ldd	r25, Y+48	; 0x30
    21ba:	9c a7       	std	Y+44, r25	; 0x2c
    21bc:	8b a7       	std	Y+43, r24	; 0x2b
    21be:	8b a5       	ldd	r24, Y+43	; 0x2b
    21c0:	9c a5       	ldd	r25, Y+44	; 0x2c
    21c2:	01 97       	sbiw	r24, 0x01	; 1
    21c4:	f1 f7       	brne	.-4      	; 0x21c2 <systemSettings+0x5e2>
    21c6:	9c a7       	std	Y+44, r25	; 0x2c
    21c8:	8b a7       	std	Y+43, r24	; 0x2b
    21ca:	ac ce       	rjmp	.-680    	; 0x1f24 <systemSettings+0x344>
				_delay_ms(500);

			}

	}
	else if (KeyPad_getPressedKey()== '+') /* change password */
    21cc:	0e 94 a3 05 	call	0xb46	; 0xb46 <KeyPad_getPressedKey>
    21d0:	8b 32       	cpi	r24, 0x2B	; 43
    21d2:	09 f0       	breq	.+2      	; 0x21d6 <systemSettings+0x5f6>
    21d4:	bf c1       	rjmp	.+894    	; 0x2554 <systemSettings+0x974>
	{
		uint8 oldPassword2[6] ;
		USART_sendByte(CHANGE_PASSWORD); /* send msg to MC2 to can understand that it will receive the old password from MC2 */
    21d6:	8c e0       	ldi	r24, 0x0C	; 12
    21d8:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>
		USART_receiveString(oldPassword); /* uart  receive the old password from MC2 to compare it with current password */
    21dc:	ce 01       	movw	r24, r28
    21de:	84 59       	subi	r24, 0x94	; 148
    21e0:	9f 4f       	sbci	r25, 0xFF	; 255
    21e2:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <USART_receiveString>

		while(1)
		{

			LCD_clearScreen();
    21e6:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
			LCD_displayString("please enter ");
    21ea:	84 e1       	ldi	r24, 0x14	; 20
    21ec:	91 e0       	ldi	r25, 0x01	; 1
    21ee:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
			LCD_goToRowColumn(1 ,0);
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	60 e0       	ldi	r22, 0x00	; 0
    21f6:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <LCD_goToRowColumn>
			LCD_displayString("old pass: ");
    21fa:	82 e2       	ldi	r24, 0x22	; 34
    21fc:	91 e0       	ldi	r25, 0x01	; 1
    21fe:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	90 e0       	ldi	r25, 0x00	; 0
    2206:	aa e7       	ldi	r26, 0x7A	; 122
    2208:	b4 e4       	ldi	r27, 0x44	; 68
    220a:	8f a3       	std	Y+39, r24	; 0x27
    220c:	98 a7       	std	Y+40, r25	; 0x28
    220e:	a9 a7       	std	Y+41, r26	; 0x29
    2210:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2212:	6f a1       	ldd	r22, Y+39	; 0x27
    2214:	78 a5       	ldd	r23, Y+40	; 0x28
    2216:	89 a5       	ldd	r24, Y+41	; 0x29
    2218:	9a a5       	ldd	r25, Y+42	; 0x2a
    221a:	20 e0       	ldi	r18, 0x00	; 0
    221c:	30 e0       	ldi	r19, 0x00	; 0
    221e:	4a e7       	ldi	r20, 0x7A	; 122
    2220:	53 e4       	ldi	r21, 0x43	; 67
    2222:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2226:	dc 01       	movw	r26, r24
    2228:	cb 01       	movw	r24, r22
    222a:	8b a3       	std	Y+35, r24	; 0x23
    222c:	9c a3       	std	Y+36, r25	; 0x24
    222e:	ad a3       	std	Y+37, r26	; 0x25
    2230:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2232:	6b a1       	ldd	r22, Y+35	; 0x23
    2234:	7c a1       	ldd	r23, Y+36	; 0x24
    2236:	8d a1       	ldd	r24, Y+37	; 0x25
    2238:	9e a1       	ldd	r25, Y+38	; 0x26
    223a:	20 e0       	ldi	r18, 0x00	; 0
    223c:	30 e0       	ldi	r19, 0x00	; 0
    223e:	40 e8       	ldi	r20, 0x80	; 128
    2240:	5f e3       	ldi	r21, 0x3F	; 63
    2242:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2246:	88 23       	and	r24, r24
    2248:	2c f4       	brge	.+10     	; 0x2254 <systemSettings+0x674>
		__ticks = 1;
    224a:	81 e0       	ldi	r24, 0x01	; 1
    224c:	90 e0       	ldi	r25, 0x00	; 0
    224e:	9a a3       	std	Y+34, r25	; 0x22
    2250:	89 a3       	std	Y+33, r24	; 0x21
    2252:	3f c0       	rjmp	.+126    	; 0x22d2 <systemSettings+0x6f2>
	else if (__tmp > 65535)
    2254:	6b a1       	ldd	r22, Y+35	; 0x23
    2256:	7c a1       	ldd	r23, Y+36	; 0x24
    2258:	8d a1       	ldd	r24, Y+37	; 0x25
    225a:	9e a1       	ldd	r25, Y+38	; 0x26
    225c:	20 e0       	ldi	r18, 0x00	; 0
    225e:	3f ef       	ldi	r19, 0xFF	; 255
    2260:	4f e7       	ldi	r20, 0x7F	; 127
    2262:	57 e4       	ldi	r21, 0x47	; 71
    2264:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2268:	18 16       	cp	r1, r24
    226a:	4c f5       	brge	.+82     	; 0x22be <systemSettings+0x6de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    226c:	6f a1       	ldd	r22, Y+39	; 0x27
    226e:	78 a5       	ldd	r23, Y+40	; 0x28
    2270:	89 a5       	ldd	r24, Y+41	; 0x29
    2272:	9a a5       	ldd	r25, Y+42	; 0x2a
    2274:	20 e0       	ldi	r18, 0x00	; 0
    2276:	30 e0       	ldi	r19, 0x00	; 0
    2278:	40 e2       	ldi	r20, 0x20	; 32
    227a:	51 e4       	ldi	r21, 0x41	; 65
    227c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2280:	dc 01       	movw	r26, r24
    2282:	cb 01       	movw	r24, r22
    2284:	bc 01       	movw	r22, r24
    2286:	cd 01       	movw	r24, r26
    2288:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    228c:	dc 01       	movw	r26, r24
    228e:	cb 01       	movw	r24, r22
    2290:	9a a3       	std	Y+34, r25	; 0x22
    2292:	89 a3       	std	Y+33, r24	; 0x21
    2294:	0f c0       	rjmp	.+30     	; 0x22b4 <systemSettings+0x6d4>
    2296:	89 e1       	ldi	r24, 0x19	; 25
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	98 a3       	std	Y+32, r25	; 0x20
    229c:	8f 8f       	std	Y+31, r24	; 0x1f
    229e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    22a0:	98 a1       	ldd	r25, Y+32	; 0x20
    22a2:	01 97       	sbiw	r24, 0x01	; 1
    22a4:	f1 f7       	brne	.-4      	; 0x22a2 <systemSettings+0x6c2>
    22a6:	98 a3       	std	Y+32, r25	; 0x20
    22a8:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22aa:	89 a1       	ldd	r24, Y+33	; 0x21
    22ac:	9a a1       	ldd	r25, Y+34	; 0x22
    22ae:	01 97       	sbiw	r24, 0x01	; 1
    22b0:	9a a3       	std	Y+34, r25	; 0x22
    22b2:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    22b4:	89 a1       	ldd	r24, Y+33	; 0x21
    22b6:	9a a1       	ldd	r25, Y+34	; 0x22
    22b8:	00 97       	sbiw	r24, 0x00	; 0
    22ba:	69 f7       	brne	.-38     	; 0x2296 <systemSettings+0x6b6>
    22bc:	14 c0       	rjmp	.+40     	; 0x22e6 <systemSettings+0x706>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    22be:	6b a1       	ldd	r22, Y+35	; 0x23
    22c0:	7c a1       	ldd	r23, Y+36	; 0x24
    22c2:	8d a1       	ldd	r24, Y+37	; 0x25
    22c4:	9e a1       	ldd	r25, Y+38	; 0x26
    22c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22ca:	dc 01       	movw	r26, r24
    22cc:	cb 01       	movw	r24, r22
    22ce:	9a a3       	std	Y+34, r25	; 0x22
    22d0:	89 a3       	std	Y+33, r24	; 0x21
    22d2:	89 a1       	ldd	r24, Y+33	; 0x21
    22d4:	9a a1       	ldd	r25, Y+34	; 0x22
    22d6:	9e 8f       	std	Y+30, r25	; 0x1e
    22d8:	8d 8f       	std	Y+29, r24	; 0x1d
    22da:	8d 8d       	ldd	r24, Y+29	; 0x1d
    22dc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    22de:	01 97       	sbiw	r24, 0x01	; 1
    22e0:	f1 f7       	brne	.-4      	; 0x22de <systemSettings+0x6fe>
    22e2:	9e 8f       	std	Y+30, r25	; 0x1e
    22e4:	8d 8f       	std	Y+29, r24	; 0x1d
			_delay_ms(1000);
			enterPassword(oldPassword2);
    22e6:	ce 01       	movw	r24, r28
    22e8:	8e 58       	subi	r24, 0x8E	; 142
    22ea:	9f 4f       	sbci	r25, 0xFF	; 255
    22ec:	0e 94 b6 12 	call	0x256c	; 0x256c <enterPassword>
			if(count ==2)
    22f0:	fe 01       	movw	r30, r28
    22f2:	eb 59       	subi	r30, 0x9B	; 155
    22f4:	ff 4f       	sbci	r31, 0xFF	; 255
    22f6:	80 81       	ld	r24, Z
    22f8:	82 30       	cpi	r24, 0x02	; 2
    22fa:	b1 f4       	brne	.+44     	; 0x2328 <systemSettings+0x748>
			 {
			   LCD_clearScreen();
    22fc:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
			   LCD_displayString("Exceed 3 times");
    2300:	85 ef       	ldi	r24, 0xF5	; 245
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
			   USART_sendByte(WRONG_PASSWORD); /* send msg to MC2 to can understand that it will turn on buzzer because the password is entered wrong 3 times */
    2308:	8f e0       	ldi	r24, 0x0F	; 15
    230a:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>

				/* recieve finising bit when the buzzer finished its work */
				uint8 buzzerOff =USART_recieveByte();
    230e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <USART_recieveByte>
    2312:	fe 01       	movw	r30, r28
    2314:	ed 59       	subi	r30, 0x9D	; 157
    2316:	ff 4f       	sbci	r31, 0xFF	; 255
    2318:	80 83       	st	Z, r24
				if(buzzerOff == BUZZER_OFF)
    231a:	fe 01       	movw	r30, r28
    231c:	ed 59       	subi	r30, 0x9D	; 157
    231e:	ff 4f       	sbci	r31, 0xFF	; 255
    2320:	80 81       	ld	r24, Z
    2322:	83 30       	cpi	r24, 0x03	; 3
    2324:	09 f4       	brne	.+2      	; 0x2328 <systemSettings+0x748>
    2326:	16 c1       	rjmp	.+556    	; 0x2554 <systemSettings+0x974>
					for (int i=0;i<12 ;i++)
					_delay_ms(60000); // delay for 1 min util buzzer finish
					break;
				 ************************************************/
			 }
			if (strcmp(oldPassword , oldPassword2)==0&& count <2)
    2328:	ce 01       	movw	r24, r28
    232a:	84 59       	subi	r24, 0x94	; 148
    232c:	9f 4f       	sbci	r25, 0xFF	; 255
    232e:	9e 01       	movw	r18, r28
    2330:	2e 58       	subi	r18, 0x8E	; 142
    2332:	3f 4f       	sbci	r19, 0xFF	; 255
    2334:	b9 01       	movw	r22, r18
    2336:	0e 94 0f 18 	call	0x301e	; 0x301e <strcmp>
    233a:	00 97       	sbiw	r24, 0x00	; 0
    233c:	09 f0       	breq	.+2      	; 0x2340 <systemSettings+0x760>
    233e:	88 c0       	rjmp	.+272    	; 0x2450 <systemSettings+0x870>
    2340:	fe 01       	movw	r30, r28
    2342:	eb 59       	subi	r30, 0x9B	; 155
    2344:	ff 4f       	sbci	r31, 0xFF	; 255
    2346:	80 81       	ld	r24, Z
    2348:	82 30       	cpi	r24, 0x02	; 2
    234a:	08 f0       	brcs	.+2      	; 0x234e <systemSettings+0x76e>
    234c:	81 c0       	rjmp	.+258    	; 0x2450 <systemSettings+0x870>
			{
				count=0;
    234e:	fe 01       	movw	r30, r28
    2350:	eb 59       	subi	r30, 0x9B	; 155
    2352:	ff 4f       	sbci	r31, 0xFF	; 255
    2354:	10 82       	st	Z, r1
				LCD_clearScreen();
    2356:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
				LCD_displayString("SUCESS "); /* display sucess  if enter the old password right */
    235a:	8d e2       	ldi	r24, 0x2D	; 45
    235c:	91 e0       	ldi	r25, 0x01	; 1
    235e:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    2362:	80 e0       	ldi	r24, 0x00	; 0
    2364:	90 e0       	ldi	r25, 0x00	; 0
    2366:	aa e7       	ldi	r26, 0x7A	; 122
    2368:	b4 e4       	ldi	r27, 0x44	; 68
    236a:	89 8f       	std	Y+25, r24	; 0x19
    236c:	9a 8f       	std	Y+26, r25	; 0x1a
    236e:	ab 8f       	std	Y+27, r26	; 0x1b
    2370:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2372:	69 8d       	ldd	r22, Y+25	; 0x19
    2374:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2376:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2378:	9c 8d       	ldd	r25, Y+28	; 0x1c
    237a:	20 e0       	ldi	r18, 0x00	; 0
    237c:	30 e0       	ldi	r19, 0x00	; 0
    237e:	4a e7       	ldi	r20, 0x7A	; 122
    2380:	53 e4       	ldi	r21, 0x43	; 67
    2382:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2386:	dc 01       	movw	r26, r24
    2388:	cb 01       	movw	r24, r22
    238a:	8d 8b       	std	Y+21, r24	; 0x15
    238c:	9e 8b       	std	Y+22, r25	; 0x16
    238e:	af 8b       	std	Y+23, r26	; 0x17
    2390:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2392:	6d 89       	ldd	r22, Y+21	; 0x15
    2394:	7e 89       	ldd	r23, Y+22	; 0x16
    2396:	8f 89       	ldd	r24, Y+23	; 0x17
    2398:	98 8d       	ldd	r25, Y+24	; 0x18
    239a:	20 e0       	ldi	r18, 0x00	; 0
    239c:	30 e0       	ldi	r19, 0x00	; 0
    239e:	40 e8       	ldi	r20, 0x80	; 128
    23a0:	5f e3       	ldi	r21, 0x3F	; 63
    23a2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    23a6:	88 23       	and	r24, r24
    23a8:	2c f4       	brge	.+10     	; 0x23b4 <systemSettings+0x7d4>
		__ticks = 1;
    23aa:	81 e0       	ldi	r24, 0x01	; 1
    23ac:	90 e0       	ldi	r25, 0x00	; 0
    23ae:	9c 8b       	std	Y+20, r25	; 0x14
    23b0:	8b 8b       	std	Y+19, r24	; 0x13
    23b2:	3f c0       	rjmp	.+126    	; 0x2432 <systemSettings+0x852>
	else if (__tmp > 65535)
    23b4:	6d 89       	ldd	r22, Y+21	; 0x15
    23b6:	7e 89       	ldd	r23, Y+22	; 0x16
    23b8:	8f 89       	ldd	r24, Y+23	; 0x17
    23ba:	98 8d       	ldd	r25, Y+24	; 0x18
    23bc:	20 e0       	ldi	r18, 0x00	; 0
    23be:	3f ef       	ldi	r19, 0xFF	; 255
    23c0:	4f e7       	ldi	r20, 0x7F	; 127
    23c2:	57 e4       	ldi	r21, 0x47	; 71
    23c4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    23c8:	18 16       	cp	r1, r24
    23ca:	4c f5       	brge	.+82     	; 0x241e <systemSettings+0x83e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23cc:	69 8d       	ldd	r22, Y+25	; 0x19
    23ce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    23d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    23d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    23d4:	20 e0       	ldi	r18, 0x00	; 0
    23d6:	30 e0       	ldi	r19, 0x00	; 0
    23d8:	40 e2       	ldi	r20, 0x20	; 32
    23da:	51 e4       	ldi	r21, 0x41	; 65
    23dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23e0:	dc 01       	movw	r26, r24
    23e2:	cb 01       	movw	r24, r22
    23e4:	bc 01       	movw	r22, r24
    23e6:	cd 01       	movw	r24, r26
    23e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23ec:	dc 01       	movw	r26, r24
    23ee:	cb 01       	movw	r24, r22
    23f0:	9c 8b       	std	Y+20, r25	; 0x14
    23f2:	8b 8b       	std	Y+19, r24	; 0x13
    23f4:	0f c0       	rjmp	.+30     	; 0x2414 <systemSettings+0x834>
    23f6:	89 e1       	ldi	r24, 0x19	; 25
    23f8:	90 e0       	ldi	r25, 0x00	; 0
    23fa:	9a 8b       	std	Y+18, r25	; 0x12
    23fc:	89 8b       	std	Y+17, r24	; 0x11
    23fe:	89 89       	ldd	r24, Y+17	; 0x11
    2400:	9a 89       	ldd	r25, Y+18	; 0x12
    2402:	01 97       	sbiw	r24, 0x01	; 1
    2404:	f1 f7       	brne	.-4      	; 0x2402 <systemSettings+0x822>
    2406:	9a 8b       	std	Y+18, r25	; 0x12
    2408:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    240a:	8b 89       	ldd	r24, Y+19	; 0x13
    240c:	9c 89       	ldd	r25, Y+20	; 0x14
    240e:	01 97       	sbiw	r24, 0x01	; 1
    2410:	9c 8b       	std	Y+20, r25	; 0x14
    2412:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2414:	8b 89       	ldd	r24, Y+19	; 0x13
    2416:	9c 89       	ldd	r25, Y+20	; 0x14
    2418:	00 97       	sbiw	r24, 0x00	; 0
    241a:	69 f7       	brne	.-38     	; 0x23f6 <systemSettings+0x816>
    241c:	14 c0       	rjmp	.+40     	; 0x2446 <systemSettings+0x866>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    241e:	6d 89       	ldd	r22, Y+21	; 0x15
    2420:	7e 89       	ldd	r23, Y+22	; 0x16
    2422:	8f 89       	ldd	r24, Y+23	; 0x17
    2424:	98 8d       	ldd	r25, Y+24	; 0x18
    2426:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    242a:	dc 01       	movw	r26, r24
    242c:	cb 01       	movw	r24, r22
    242e:	9c 8b       	std	Y+20, r25	; 0x14
    2430:	8b 8b       	std	Y+19, r24	; 0x13
    2432:	8b 89       	ldd	r24, Y+19	; 0x13
    2434:	9c 89       	ldd	r25, Y+20	; 0x14
    2436:	98 8b       	std	Y+16, r25	; 0x10
    2438:	8f 87       	std	Y+15, r24	; 0x0f
    243a:	8f 85       	ldd	r24, Y+15	; 0x0f
    243c:	98 89       	ldd	r25, Y+16	; 0x10
    243e:	01 97       	sbiw	r24, 0x01	; 1
    2440:	f1 f7       	brne	.-4      	; 0x243e <systemSettings+0x85e>
    2442:	98 8b       	std	Y+16, r25	; 0x10
    2444:	8f 87       	std	Y+15, r24	; 0x0f
				_delay_ms(1000);
				LCD_clearScreen();
    2446:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
				signUp(); /* return back to sign up function to change password and enter the new one  */
    244a:	0e 94 ac 0b 	call	0x1758	; 0x1758 <signUp>
    244e:	82 c0       	rjmp	.+260    	; 0x2554 <systemSettings+0x974>
				break;
			}
			count++;
    2450:	de 01       	movw	r26, r28
    2452:	ab 59       	subi	r26, 0x9B	; 155
    2454:	bf 4f       	sbci	r27, 0xFF	; 255
    2456:	fe 01       	movw	r30, r28
    2458:	eb 59       	subi	r30, 0x9B	; 155
    245a:	ff 4f       	sbci	r31, 0xFF	; 255
    245c:	80 81       	ld	r24, Z
    245e:	8f 5f       	subi	r24, 0xFF	; 255
    2460:	8c 93       	st	X, r24
			LCD_clearScreen();
    2462:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
			LCD_displayString("invalid match");  /* display invalid if enter the old password 3 times wrong */
    2466:	82 ea       	ldi	r24, 0xA2	; 162
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    246e:	80 e0       	ldi	r24, 0x00	; 0
    2470:	90 e0       	ldi	r25, 0x00	; 0
    2472:	aa ef       	ldi	r26, 0xFA	; 250
    2474:	b3 e4       	ldi	r27, 0x43	; 67
    2476:	8b 87       	std	Y+11, r24	; 0x0b
    2478:	9c 87       	std	Y+12, r25	; 0x0c
    247a:	ad 87       	std	Y+13, r26	; 0x0d
    247c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    247e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2480:	7c 85       	ldd	r23, Y+12	; 0x0c
    2482:	8d 85       	ldd	r24, Y+13	; 0x0d
    2484:	9e 85       	ldd	r25, Y+14	; 0x0e
    2486:	20 e0       	ldi	r18, 0x00	; 0
    2488:	30 e0       	ldi	r19, 0x00	; 0
    248a:	4a e7       	ldi	r20, 0x7A	; 122
    248c:	53 e4       	ldi	r21, 0x43	; 67
    248e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2492:	dc 01       	movw	r26, r24
    2494:	cb 01       	movw	r24, r22
    2496:	8f 83       	std	Y+7, r24	; 0x07
    2498:	98 87       	std	Y+8, r25	; 0x08
    249a:	a9 87       	std	Y+9, r26	; 0x09
    249c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    249e:	6f 81       	ldd	r22, Y+7	; 0x07
    24a0:	78 85       	ldd	r23, Y+8	; 0x08
    24a2:	89 85       	ldd	r24, Y+9	; 0x09
    24a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    24a6:	20 e0       	ldi	r18, 0x00	; 0
    24a8:	30 e0       	ldi	r19, 0x00	; 0
    24aa:	40 e8       	ldi	r20, 0x80	; 128
    24ac:	5f e3       	ldi	r21, 0x3F	; 63
    24ae:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    24b2:	88 23       	and	r24, r24
    24b4:	2c f4       	brge	.+10     	; 0x24c0 <systemSettings+0x8e0>
		__ticks = 1;
    24b6:	81 e0       	ldi	r24, 0x01	; 1
    24b8:	90 e0       	ldi	r25, 0x00	; 0
    24ba:	9e 83       	std	Y+6, r25	; 0x06
    24bc:	8d 83       	std	Y+5, r24	; 0x05
    24be:	3f c0       	rjmp	.+126    	; 0x253e <systemSettings+0x95e>
	else if (__tmp > 65535)
    24c0:	6f 81       	ldd	r22, Y+7	; 0x07
    24c2:	78 85       	ldd	r23, Y+8	; 0x08
    24c4:	89 85       	ldd	r24, Y+9	; 0x09
    24c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    24c8:	20 e0       	ldi	r18, 0x00	; 0
    24ca:	3f ef       	ldi	r19, 0xFF	; 255
    24cc:	4f e7       	ldi	r20, 0x7F	; 127
    24ce:	57 e4       	ldi	r21, 0x47	; 71
    24d0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    24d4:	18 16       	cp	r1, r24
    24d6:	4c f5       	brge	.+82     	; 0x252a <systemSettings+0x94a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    24d8:	6b 85       	ldd	r22, Y+11	; 0x0b
    24da:	7c 85       	ldd	r23, Y+12	; 0x0c
    24dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    24de:	9e 85       	ldd	r25, Y+14	; 0x0e
    24e0:	20 e0       	ldi	r18, 0x00	; 0
    24e2:	30 e0       	ldi	r19, 0x00	; 0
    24e4:	40 e2       	ldi	r20, 0x20	; 32
    24e6:	51 e4       	ldi	r21, 0x41	; 65
    24e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24ec:	dc 01       	movw	r26, r24
    24ee:	cb 01       	movw	r24, r22
    24f0:	bc 01       	movw	r22, r24
    24f2:	cd 01       	movw	r24, r26
    24f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24f8:	dc 01       	movw	r26, r24
    24fa:	cb 01       	movw	r24, r22
    24fc:	9e 83       	std	Y+6, r25	; 0x06
    24fe:	8d 83       	std	Y+5, r24	; 0x05
    2500:	0f c0       	rjmp	.+30     	; 0x2520 <systemSettings+0x940>
    2502:	89 e1       	ldi	r24, 0x19	; 25
    2504:	90 e0       	ldi	r25, 0x00	; 0
    2506:	9c 83       	std	Y+4, r25	; 0x04
    2508:	8b 83       	std	Y+3, r24	; 0x03
    250a:	8b 81       	ldd	r24, Y+3	; 0x03
    250c:	9c 81       	ldd	r25, Y+4	; 0x04
    250e:	01 97       	sbiw	r24, 0x01	; 1
    2510:	f1 f7       	brne	.-4      	; 0x250e <systemSettings+0x92e>
    2512:	9c 83       	std	Y+4, r25	; 0x04
    2514:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2516:	8d 81       	ldd	r24, Y+5	; 0x05
    2518:	9e 81       	ldd	r25, Y+6	; 0x06
    251a:	01 97       	sbiw	r24, 0x01	; 1
    251c:	9e 83       	std	Y+6, r25	; 0x06
    251e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2520:	8d 81       	ldd	r24, Y+5	; 0x05
    2522:	9e 81       	ldd	r25, Y+6	; 0x06
    2524:	00 97       	sbiw	r24, 0x00	; 0
    2526:	69 f7       	brne	.-38     	; 0x2502 <systemSettings+0x922>
    2528:	5e ce       	rjmp	.-836    	; 0x21e6 <systemSettings+0x606>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    252a:	6f 81       	ldd	r22, Y+7	; 0x07
    252c:	78 85       	ldd	r23, Y+8	; 0x08
    252e:	89 85       	ldd	r24, Y+9	; 0x09
    2530:	9a 85       	ldd	r25, Y+10	; 0x0a
    2532:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2536:	dc 01       	movw	r26, r24
    2538:	cb 01       	movw	r24, r22
    253a:	9e 83       	std	Y+6, r25	; 0x06
    253c:	8d 83       	std	Y+5, r24	; 0x05
    253e:	8d 81       	ldd	r24, Y+5	; 0x05
    2540:	9e 81       	ldd	r25, Y+6	; 0x06
    2542:	9a 83       	std	Y+2, r25	; 0x02
    2544:	89 83       	std	Y+1, r24	; 0x01
    2546:	89 81       	ldd	r24, Y+1	; 0x01
    2548:	9a 81       	ldd	r25, Y+2	; 0x02
    254a:	01 97       	sbiw	r24, 0x01	; 1
    254c:	f1 f7       	brne	.-4      	; 0x254a <systemSettings+0x96a>
    254e:	9a 83       	std	Y+2, r25	; 0x02
    2550:	89 83       	std	Y+1, r24	; 0x01
    2552:	49 ce       	rjmp	.-878    	; 0x21e6 <systemSettings+0x606>
			_delay_ms(500);
			}
		}

}
    2554:	c9 58       	subi	r28, 0x89	; 137
    2556:	df 4f       	sbci	r29, 0xFF	; 255
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	de bf       	out	0x3e, r29	; 62
    255e:	0f be       	out	0x3f, r0	; 63
    2560:	cd bf       	out	0x3d, r28	; 61
    2562:	cf 91       	pop	r28
    2564:	df 91       	pop	r29
    2566:	1f 91       	pop	r17
    2568:	0f 91       	pop	r16
    256a:	08 95       	ret

0000256c <enterPassword>:

/* function that save password in buffer after convert it to character */
void enterPassword (char * passwordArr)
{
    256c:	0f 93       	push	r16
    256e:	1f 93       	push	r17
    2570:	df 93       	push	r29
    2572:	cf 93       	push	r28
    2574:	cd b7       	in	r28, 0x3d	; 61
    2576:	de b7       	in	r29, 0x3e	; 62
    2578:	63 97       	sbiw	r28, 0x13	; 19
    257a:	0f b6       	in	r0, 0x3f	; 63
    257c:	f8 94       	cli
    257e:	de bf       	out	0x3e, r29	; 62
    2580:	0f be       	out	0x3f, r0	; 63
    2582:	cd bf       	out	0x3d, r28	; 61
    2584:	9b 8b       	std	Y+19, r25	; 0x13
    2586:	8a 8b       	std	Y+18, r24	; 0x12
	uint8 key ;
	for (int i=0;i<5;i++)
    2588:	18 8a       	std	Y+16, r1	; 0x10
    258a:	1f 86       	std	Y+15, r1	; 0x0f
    258c:	86 c0       	rjmp	.+268    	; 0x269a <enterPassword+0x12e>
	{
		/* convert from number to character then , put them in the array*/
		passwordArr[i] = KeyPad_getPressedKey()+48; /* 48 -> is the ascii of character 0 */
    258e:	2f 85       	ldd	r18, Y+15	; 0x0f
    2590:	38 89       	ldd	r19, Y+16	; 0x10
    2592:	8a 89       	ldd	r24, Y+18	; 0x12
    2594:	9b 89       	ldd	r25, Y+19	; 0x13
    2596:	8c 01       	movw	r16, r24
    2598:	02 0f       	add	r16, r18
    259a:	13 1f       	adc	r17, r19
    259c:	0e 94 a3 05 	call	0xb46	; 0xb46 <KeyPad_getPressedKey>
    25a0:	80 5d       	subi	r24, 0xD0	; 208
    25a2:	f8 01       	movw	r30, r16
    25a4:	80 83       	st	Z, r24
		LCD_displayCharacter('*');
    25a6:	8a e2       	ldi	r24, 0x2A	; 42
    25a8:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_displayCharacter>
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	aa ef       	ldi	r26, 0xFA	; 250
    25b2:	b3 e4       	ldi	r27, 0x43	; 67
    25b4:	8b 87       	std	Y+11, r24	; 0x0b
    25b6:	9c 87       	std	Y+12, r25	; 0x0c
    25b8:	ad 87       	std	Y+13, r26	; 0x0d
    25ba:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    25bc:	6b 85       	ldd	r22, Y+11	; 0x0b
    25be:	7c 85       	ldd	r23, Y+12	; 0x0c
    25c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    25c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    25c4:	20 e0       	ldi	r18, 0x00	; 0
    25c6:	30 e0       	ldi	r19, 0x00	; 0
    25c8:	4a e7       	ldi	r20, 0x7A	; 122
    25ca:	53 e4       	ldi	r21, 0x43	; 67
    25cc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25d0:	dc 01       	movw	r26, r24
    25d2:	cb 01       	movw	r24, r22
    25d4:	8f 83       	std	Y+7, r24	; 0x07
    25d6:	98 87       	std	Y+8, r25	; 0x08
    25d8:	a9 87       	std	Y+9, r26	; 0x09
    25da:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    25dc:	6f 81       	ldd	r22, Y+7	; 0x07
    25de:	78 85       	ldd	r23, Y+8	; 0x08
    25e0:	89 85       	ldd	r24, Y+9	; 0x09
    25e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    25e4:	20 e0       	ldi	r18, 0x00	; 0
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	40 e8       	ldi	r20, 0x80	; 128
    25ea:	5f e3       	ldi	r21, 0x3F	; 63
    25ec:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    25f0:	88 23       	and	r24, r24
    25f2:	2c f4       	brge	.+10     	; 0x25fe <enterPassword+0x92>
		__ticks = 1;
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	90 e0       	ldi	r25, 0x00	; 0
    25f8:	9e 83       	std	Y+6, r25	; 0x06
    25fa:	8d 83       	std	Y+5, r24	; 0x05
    25fc:	3f c0       	rjmp	.+126    	; 0x267c <enterPassword+0x110>
	else if (__tmp > 65535)
    25fe:	6f 81       	ldd	r22, Y+7	; 0x07
    2600:	78 85       	ldd	r23, Y+8	; 0x08
    2602:	89 85       	ldd	r24, Y+9	; 0x09
    2604:	9a 85       	ldd	r25, Y+10	; 0x0a
    2606:	20 e0       	ldi	r18, 0x00	; 0
    2608:	3f ef       	ldi	r19, 0xFF	; 255
    260a:	4f e7       	ldi	r20, 0x7F	; 127
    260c:	57 e4       	ldi	r21, 0x47	; 71
    260e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2612:	18 16       	cp	r1, r24
    2614:	4c f5       	brge	.+82     	; 0x2668 <enterPassword+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2616:	6b 85       	ldd	r22, Y+11	; 0x0b
    2618:	7c 85       	ldd	r23, Y+12	; 0x0c
    261a:	8d 85       	ldd	r24, Y+13	; 0x0d
    261c:	9e 85       	ldd	r25, Y+14	; 0x0e
    261e:	20 e0       	ldi	r18, 0x00	; 0
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	40 e2       	ldi	r20, 0x20	; 32
    2624:	51 e4       	ldi	r21, 0x41	; 65
    2626:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    262a:	dc 01       	movw	r26, r24
    262c:	cb 01       	movw	r24, r22
    262e:	bc 01       	movw	r22, r24
    2630:	cd 01       	movw	r24, r26
    2632:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2636:	dc 01       	movw	r26, r24
    2638:	cb 01       	movw	r24, r22
    263a:	9e 83       	std	Y+6, r25	; 0x06
    263c:	8d 83       	std	Y+5, r24	; 0x05
    263e:	0f c0       	rjmp	.+30     	; 0x265e <enterPassword+0xf2>
    2640:	89 e1       	ldi	r24, 0x19	; 25
    2642:	90 e0       	ldi	r25, 0x00	; 0
    2644:	9c 83       	std	Y+4, r25	; 0x04
    2646:	8b 83       	std	Y+3, r24	; 0x03
    2648:	8b 81       	ldd	r24, Y+3	; 0x03
    264a:	9c 81       	ldd	r25, Y+4	; 0x04
    264c:	01 97       	sbiw	r24, 0x01	; 1
    264e:	f1 f7       	brne	.-4      	; 0x264c <enterPassword+0xe0>
    2650:	9c 83       	std	Y+4, r25	; 0x04
    2652:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2654:	8d 81       	ldd	r24, Y+5	; 0x05
    2656:	9e 81       	ldd	r25, Y+6	; 0x06
    2658:	01 97       	sbiw	r24, 0x01	; 1
    265a:	9e 83       	std	Y+6, r25	; 0x06
    265c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    265e:	8d 81       	ldd	r24, Y+5	; 0x05
    2660:	9e 81       	ldd	r25, Y+6	; 0x06
    2662:	00 97       	sbiw	r24, 0x00	; 0
    2664:	69 f7       	brne	.-38     	; 0x2640 <enterPassword+0xd4>
    2666:	14 c0       	rjmp	.+40     	; 0x2690 <enterPassword+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2668:	6f 81       	ldd	r22, Y+7	; 0x07
    266a:	78 85       	ldd	r23, Y+8	; 0x08
    266c:	89 85       	ldd	r24, Y+9	; 0x09
    266e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2670:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2674:	dc 01       	movw	r26, r24
    2676:	cb 01       	movw	r24, r22
    2678:	9e 83       	std	Y+6, r25	; 0x06
    267a:	8d 83       	std	Y+5, r24	; 0x05
    267c:	8d 81       	ldd	r24, Y+5	; 0x05
    267e:	9e 81       	ldd	r25, Y+6	; 0x06
    2680:	9a 83       	std	Y+2, r25	; 0x02
    2682:	89 83       	std	Y+1, r24	; 0x01
    2684:	89 81       	ldd	r24, Y+1	; 0x01
    2686:	9a 81       	ldd	r25, Y+2	; 0x02
    2688:	01 97       	sbiw	r24, 0x01	; 1
    268a:	f1 f7       	brne	.-4      	; 0x2688 <enterPassword+0x11c>
    268c:	9a 83       	std	Y+2, r25	; 0x02
    268e:	89 83       	std	Y+1, r24	; 0x01

/* function that save password in buffer after convert it to character */
void enterPassword (char * passwordArr)
{
	uint8 key ;
	for (int i=0;i<5;i++)
    2690:	8f 85       	ldd	r24, Y+15	; 0x0f
    2692:	98 89       	ldd	r25, Y+16	; 0x10
    2694:	01 96       	adiw	r24, 0x01	; 1
    2696:	98 8b       	std	Y+16, r25	; 0x10
    2698:	8f 87       	std	Y+15, r24	; 0x0f
    269a:	8f 85       	ldd	r24, Y+15	; 0x0f
    269c:	98 89       	ldd	r25, Y+16	; 0x10
    269e:	85 30       	cpi	r24, 0x05	; 5
    26a0:	91 05       	cpc	r25, r1
    26a2:	0c f4       	brge	.+2      	; 0x26a6 <enterPassword+0x13a>
    26a4:	74 cf       	rjmp	.-280    	; 0x258e <enterPassword+0x22>
		/* convert from number to character then , put them in the array*/
		passwordArr[i] = KeyPad_getPressedKey()+48; /* 48 -> is the ascii of character 0 */
		LCD_displayCharacter('*');
		_delay_ms(500); /* press time */
	}
	passwordArr[5]='\0';
    26a6:	8a 89       	ldd	r24, Y+18	; 0x12
    26a8:	9b 89       	ldd	r25, Y+19	; 0x13
    26aa:	fc 01       	movw	r30, r24
    26ac:	35 96       	adiw	r30, 0x05	; 5
    26ae:	10 82       	st	Z, r1
}
    26b0:	63 96       	adiw	r28, 0x13	; 19
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
    26bc:	cf 91       	pop	r28
    26be:	df 91       	pop	r29
    26c0:	1f 91       	pop	r17
    26c2:	0f 91       	pop	r16
    26c4:	08 95       	ret

000026c6 <prepareToSend>:

/* function to add # to the new password in the buffer that is save in to prepare send it by uart to MC2 */
void prepareToSend(uint8 array[], uint8 array2[])
{
    26c6:	df 93       	push	r29
    26c8:	cf 93       	push	r28
    26ca:	00 d0       	rcall	.+0      	; 0x26cc <prepareToSend+0x6>
    26cc:	00 d0       	rcall	.+0      	; 0x26ce <prepareToSend+0x8>
    26ce:	0f 92       	push	r0
    26d0:	cd b7       	in	r28, 0x3d	; 61
    26d2:	de b7       	in	r29, 0x3e	; 62
    26d4:	9b 83       	std	Y+3, r25	; 0x03
    26d6:	8a 83       	std	Y+2, r24	; 0x02
    26d8:	7d 83       	std	Y+5, r23	; 0x05
    26da:	6c 83       	std	Y+4, r22	; 0x04
	sint8 i = 0;
    26dc:	19 82       	std	Y+1, r1	; 0x01
	for (i = 0; i < 6; i++)
    26de:	19 82       	std	Y+1, r1	; 0x01
    26e0:	28 c0       	rjmp	.+80     	; 0x2732 <prepareToSend+0x6c>
	{
		array2[i] = array[i];
    26e2:	89 81       	ldd	r24, Y+1	; 0x01
    26e4:	28 2f       	mov	r18, r24
    26e6:	33 27       	eor	r19, r19
    26e8:	27 fd       	sbrc	r18, 7
    26ea:	30 95       	com	r19
    26ec:	8c 81       	ldd	r24, Y+4	; 0x04
    26ee:	9d 81       	ldd	r25, Y+5	; 0x05
    26f0:	dc 01       	movw	r26, r24
    26f2:	a2 0f       	add	r26, r18
    26f4:	b3 1f       	adc	r27, r19
    26f6:	89 81       	ldd	r24, Y+1	; 0x01
    26f8:	28 2f       	mov	r18, r24
    26fa:	33 27       	eor	r19, r19
    26fc:	27 fd       	sbrc	r18, 7
    26fe:	30 95       	com	r19
    2700:	8a 81       	ldd	r24, Y+2	; 0x02
    2702:	9b 81       	ldd	r25, Y+3	; 0x03
    2704:	fc 01       	movw	r30, r24
    2706:	e2 0f       	add	r30, r18
    2708:	f3 1f       	adc	r31, r19
    270a:	80 81       	ld	r24, Z
    270c:	8c 93       	st	X, r24
		if (i == 5)
    270e:	89 81       	ldd	r24, Y+1	; 0x01
    2710:	85 30       	cpi	r24, 0x05	; 5
    2712:	61 f4       	brne	.+24     	; 0x272c <prepareToSend+0x66>
		{
			array2[i] = '#';
    2714:	89 81       	ldd	r24, Y+1	; 0x01
    2716:	28 2f       	mov	r18, r24
    2718:	33 27       	eor	r19, r19
    271a:	27 fd       	sbrc	r18, 7
    271c:	30 95       	com	r19
    271e:	8c 81       	ldd	r24, Y+4	; 0x04
    2720:	9d 81       	ldd	r25, Y+5	; 0x05
    2722:	fc 01       	movw	r30, r24
    2724:	e2 0f       	add	r30, r18
    2726:	f3 1f       	adc	r31, r19
    2728:	83 e2       	ldi	r24, 0x23	; 35
    272a:	80 83       	st	Z, r24

/* function to add # to the new password in the buffer that is save in to prepare send it by uart to MC2 */
void prepareToSend(uint8 array[], uint8 array2[])
{
	sint8 i = 0;
	for (i = 0; i < 6; i++)
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	8f 5f       	subi	r24, 0xFF	; 255
    2730:	89 83       	std	Y+1, r24	; 0x01
    2732:	89 81       	ldd	r24, Y+1	; 0x01
    2734:	86 30       	cpi	r24, 0x06	; 6
    2736:	ac f2       	brlt	.-86     	; 0x26e2 <prepareToSend+0x1c>
		{
			array2[i] = '#';
			//break;
		}
	}
	array2[i] ='\0';
    2738:	89 81       	ldd	r24, Y+1	; 0x01
    273a:	28 2f       	mov	r18, r24
    273c:	33 27       	eor	r19, r19
    273e:	27 fd       	sbrc	r18, 7
    2740:	30 95       	com	r19
    2742:	8c 81       	ldd	r24, Y+4	; 0x04
    2744:	9d 81       	ldd	r25, Y+5	; 0x05
    2746:	fc 01       	movw	r30, r24
    2748:	e2 0f       	add	r30, r18
    274a:	f3 1f       	adc	r31, r19
    274c:	10 82       	st	Z, r1
}
    274e:	0f 90       	pop	r0
    2750:	0f 90       	pop	r0
    2752:	0f 90       	pop	r0
    2754:	0f 90       	pop	r0
    2756:	0f 90       	pop	r0
    2758:	cf 91       	pop	r28
    275a:	df 91       	pop	r29
    275c:	08 95       	ret

0000275e <Timer_lcd_unlocking>:

/* function that pass to another function ,it display the door is unlocking for 15s when the door is opening ,then display the door is locking after 15s when the door is closed  in the MC2 */
void Timer_lcd_unlocking()
{
    275e:	df 93       	push	r29
    2760:	cf 93       	push	r28
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
	counter ++;
    2766:	80 91 4b 01 	lds	r24, 0x014B
    276a:	8f 5f       	subi	r24, 0xFF	; 255
    276c:	80 93 4b 01 	sts	0x014B, r24
	if (counter ==15)
    2770:	80 91 4b 01 	lds	r24, 0x014B
    2774:	8f 30       	cpi	r24, 0x0F	; 15
    2776:	39 f4       	brne	.+14     	; 0x2786 <Timer_lcd_unlocking+0x28>
	{
		LCD_clearScreen();
    2778:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
		LCD_displayString("Door closing");
    277c:	85 e3       	ldi	r24, 0x35	; 53
    277e:	91 e0       	ldi	r25, 0x01	; 1
    2780:	0e 94 b4 0a 	call	0x1568	; 0x1568 <LCD_displayString>
    2784:	08 c0       	rjmp	.+16     	; 0x2796 <Timer_lcd_unlocking+0x38>
	}
	else if (counter == 30)
    2786:	80 91 4b 01 	lds	r24, 0x014B
    278a:	8e 31       	cpi	r24, 0x1E	; 30
    278c:	21 f4       	brne	.+8      	; 0x2796 <Timer_lcd_unlocking+0x38>
	{

		LCD_clearScreen();
    278e:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <LCD_clearScreen>
		openingMsgFlag=0;
    2792:	10 92 4c 01 	sts	0x014C, r1
		//systemSettings();
		//TIMER1_stop();
	}
}
    2796:	cf 91       	pop	r28
    2798:	df 91       	pop	r29
    279a:	08 95       	ret

0000279c <prepareTimer>:

/* prepare timer and set its configuration */
void prepareTimer()
{
    279c:	df 93       	push	r29
    279e:	cf 93       	push	r28
    27a0:	cd b7       	in	r28, 0x3d	; 61
    27a2:	de b7       	in	r29, 0x3e	; 62
    27a4:	28 97       	sbiw	r28, 0x08	; 8
    27a6:	0f b6       	in	r0, 0x3f	; 63
    27a8:	f8 94       	cli
    27aa:	de bf       	out	0x3e, r29	; 62
    27ac:	0f be       	out	0x3f, r0	; 63
    27ae:	cd bf       	out	0x3d, r28	; 61

	/* prepare time */
	TIMER_config config; // set timer configrations
	config.channel= timer1;
    27b0:	81 e0       	ldi	r24, 0x01	; 1
    27b2:	89 83       	std	Y+1, r24	; 0x01
	config.waveMode.TIMER1_waveMode= TIMER1_CTC_OCR1A;
    27b4:	84 e0       	ldi	r24, 0x04	; 4
    27b6:	8b 83       	std	Y+3, r24	; 0x03
	config.clock.Timer_0_1_clock = TIMER_0_1_FCPU_64;
    27b8:	83 e0       	ldi	r24, 0x03	; 3
    27ba:	8c 83       	std	Y+4, r24	; 0x04
	config.initalValue =0;
    27bc:	1e 82       	std	Y+6, r1	; 0x06
    27be:	1d 82       	std	Y+5, r1	; 0x05
	config.finalValue = 15624;
    27c0:	88 e0       	ldi	r24, 0x08	; 8
    27c2:	9d e3       	ldi	r25, 0x3D	; 61
    27c4:	98 87       	std	Y+8, r25	; 0x08
    27c6:	8f 83       	std	Y+7, r24	; 0x07
	config.compOut=0;
    27c8:	1a 82       	std	Y+2, r1	; 0x02
	SREG |=(1<<7); // I BIT Enable
    27ca:	af e5       	ldi	r26, 0x5F	; 95
    27cc:	b0 e0       	ldi	r27, 0x00	; 0
    27ce:	ef e5       	ldi	r30, 0x5F	; 95
    27d0:	f0 e0       	ldi	r31, 0x00	; 0
    27d2:	80 81       	ld	r24, Z
    27d4:	80 68       	ori	r24, 0x80	; 128
    27d6:	8c 93       	st	X, r24
	TIMER_init(&config);
    27d8:	ce 01       	movw	r24, r28
    27da:	01 96       	adiw	r24, 0x01	; 1
    27dc:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <TIMER_init>
	Timer1_setCallBack(Timer_lcd_unlocking);
    27e0:	8f ea       	ldi	r24, 0xAF	; 175
    27e2:	93 e1       	ldi	r25, 0x13	; 19
    27e4:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <Timer1_setCallBack>

}
    27e8:	28 96       	adiw	r28, 0x08	; 8
    27ea:	0f b6       	in	r0, 0x3f	; 63
    27ec:	f8 94       	cli
    27ee:	de bf       	out	0x3e, r29	; 62
    27f0:	0f be       	out	0x3f, r0	; 63
    27f2:	cd bf       	out	0x3d, r28	; 61
    27f4:	cf 91       	pop	r28
    27f6:	df 91       	pop	r29
    27f8:	08 95       	ret

000027fa <__vector_9>:
 *******************************************************************************/


/*ISR for Timer 0  Normal mode */
ISR(TIMER0_OVF_vect)
{
    27fa:	1f 92       	push	r1
    27fc:	0f 92       	push	r0
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	0f 92       	push	r0
    2802:	11 24       	eor	r1, r1
    2804:	2f 93       	push	r18
    2806:	3f 93       	push	r19
    2808:	4f 93       	push	r20
    280a:	5f 93       	push	r21
    280c:	6f 93       	push	r22
    280e:	7f 93       	push	r23
    2810:	8f 93       	push	r24
    2812:	9f 93       	push	r25
    2814:	af 93       	push	r26
    2816:	bf 93       	push	r27
    2818:	ef 93       	push	r30
    281a:	ff 93       	push	r31
    281c:	df 93       	push	r29
    281e:	cf 93       	push	r28
    2820:	cd b7       	in	r28, 0x3d	; 61
    2822:	de b7       	in	r29, 0x3e	; 62
   if(g_CallBackPtr0!=NULL)
    2824:	80 91 4d 01 	lds	r24, 0x014D
    2828:	90 91 4e 01 	lds	r25, 0x014E
    282c:	00 97       	sbiw	r24, 0x00	; 0
    282e:	29 f0       	breq	.+10     	; 0x283a <__vector_9+0x40>
      {
	   (*g_CallBackPtr0)();
    2830:	e0 91 4d 01 	lds	r30, 0x014D
    2834:	f0 91 4e 01 	lds	r31, 0x014E
    2838:	09 95       	icall
      }

}
    283a:	cf 91       	pop	r28
    283c:	df 91       	pop	r29
    283e:	ff 91       	pop	r31
    2840:	ef 91       	pop	r30
    2842:	bf 91       	pop	r27
    2844:	af 91       	pop	r26
    2846:	9f 91       	pop	r25
    2848:	8f 91       	pop	r24
    284a:	7f 91       	pop	r23
    284c:	6f 91       	pop	r22
    284e:	5f 91       	pop	r21
    2850:	4f 91       	pop	r20
    2852:	3f 91       	pop	r19
    2854:	2f 91       	pop	r18
    2856:	0f 90       	pop	r0
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	0f 90       	pop	r0
    285c:	1f 90       	pop	r1
    285e:	18 95       	reti

00002860 <__vector_8>:

/*ISR for Timer 1  Normal mode */
ISR(TIMER1_OVF_vect)
{
    2860:	1f 92       	push	r1
    2862:	0f 92       	push	r0
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	0f 92       	push	r0
    2868:	11 24       	eor	r1, r1
    286a:	2f 93       	push	r18
    286c:	3f 93       	push	r19
    286e:	4f 93       	push	r20
    2870:	5f 93       	push	r21
    2872:	6f 93       	push	r22
    2874:	7f 93       	push	r23
    2876:	8f 93       	push	r24
    2878:	9f 93       	push	r25
    287a:	af 93       	push	r26
    287c:	bf 93       	push	r27
    287e:	ef 93       	push	r30
    2880:	ff 93       	push	r31
    2882:	df 93       	push	r29
    2884:	cf 93       	push	r28
    2886:	cd b7       	in	r28, 0x3d	; 61
    2888:	de b7       	in	r29, 0x3e	; 62
   if(g_CallBackPtr1!=NULL)
    288a:	80 91 4f 01 	lds	r24, 0x014F
    288e:	90 91 50 01 	lds	r25, 0x0150
    2892:	00 97       	sbiw	r24, 0x00	; 0
    2894:	29 f0       	breq	.+10     	; 0x28a0 <__vector_8+0x40>
      {
	   (*g_CallBackPtr1)();
    2896:	e0 91 4f 01 	lds	r30, 0x014F
    289a:	f0 91 50 01 	lds	r31, 0x0150
    289e:	09 95       	icall
      }

}
    28a0:	cf 91       	pop	r28
    28a2:	df 91       	pop	r29
    28a4:	ff 91       	pop	r31
    28a6:	ef 91       	pop	r30
    28a8:	bf 91       	pop	r27
    28aa:	af 91       	pop	r26
    28ac:	9f 91       	pop	r25
    28ae:	8f 91       	pop	r24
    28b0:	7f 91       	pop	r23
    28b2:	6f 91       	pop	r22
    28b4:	5f 91       	pop	r21
    28b6:	4f 91       	pop	r20
    28b8:	3f 91       	pop	r19
    28ba:	2f 91       	pop	r18
    28bc:	0f 90       	pop	r0
    28be:	0f be       	out	0x3f, r0	; 63
    28c0:	0f 90       	pop	r0
    28c2:	1f 90       	pop	r1
    28c4:	18 95       	reti

000028c6 <__vector_4>:

/*ISR for Timer 2  Normal mode */
ISR(TIMER2_OVF_vect)
{
    28c6:	1f 92       	push	r1
    28c8:	0f 92       	push	r0
    28ca:	0f b6       	in	r0, 0x3f	; 63
    28cc:	0f 92       	push	r0
    28ce:	11 24       	eor	r1, r1
    28d0:	2f 93       	push	r18
    28d2:	3f 93       	push	r19
    28d4:	4f 93       	push	r20
    28d6:	5f 93       	push	r21
    28d8:	6f 93       	push	r22
    28da:	7f 93       	push	r23
    28dc:	8f 93       	push	r24
    28de:	9f 93       	push	r25
    28e0:	af 93       	push	r26
    28e2:	bf 93       	push	r27
    28e4:	ef 93       	push	r30
    28e6:	ff 93       	push	r31
    28e8:	df 93       	push	r29
    28ea:	cf 93       	push	r28
    28ec:	cd b7       	in	r28, 0x3d	; 61
    28ee:	de b7       	in	r29, 0x3e	; 62
   if(g_CallBackPtr2!=NULL)
    28f0:	80 91 51 01 	lds	r24, 0x0151
    28f4:	90 91 52 01 	lds	r25, 0x0152
    28f8:	00 97       	sbiw	r24, 0x00	; 0
    28fa:	29 f0       	breq	.+10     	; 0x2906 <__vector_4+0x40>
      {
	   (*g_CallBackPtr2)();
    28fc:	e0 91 51 01 	lds	r30, 0x0151
    2900:	f0 91 52 01 	lds	r31, 0x0152
    2904:	09 95       	icall
      }

}
    2906:	cf 91       	pop	r28
    2908:	df 91       	pop	r29
    290a:	ff 91       	pop	r31
    290c:	ef 91       	pop	r30
    290e:	bf 91       	pop	r27
    2910:	af 91       	pop	r26
    2912:	9f 91       	pop	r25
    2914:	8f 91       	pop	r24
    2916:	7f 91       	pop	r23
    2918:	6f 91       	pop	r22
    291a:	5f 91       	pop	r21
    291c:	4f 91       	pop	r20
    291e:	3f 91       	pop	r19
    2920:	2f 91       	pop	r18
    2922:	0f 90       	pop	r0
    2924:	0f be       	out	0x3f, r0	; 63
    2926:	0f 90       	pop	r0
    2928:	1f 90       	pop	r1
    292a:	18 95       	reti

0000292c <__vector_19>:

/*ISR for Timer 0  Compare mode */
ISR(TIMER0_COMP_vect)
{
    292c:	1f 92       	push	r1
    292e:	0f 92       	push	r0
    2930:	0f b6       	in	r0, 0x3f	; 63
    2932:	0f 92       	push	r0
    2934:	11 24       	eor	r1, r1
    2936:	2f 93       	push	r18
    2938:	3f 93       	push	r19
    293a:	4f 93       	push	r20
    293c:	5f 93       	push	r21
    293e:	6f 93       	push	r22
    2940:	7f 93       	push	r23
    2942:	8f 93       	push	r24
    2944:	9f 93       	push	r25
    2946:	af 93       	push	r26
    2948:	bf 93       	push	r27
    294a:	ef 93       	push	r30
    294c:	ff 93       	push	r31
    294e:	df 93       	push	r29
    2950:	cf 93       	push	r28
    2952:	cd b7       	in	r28, 0x3d	; 61
    2954:	de b7       	in	r29, 0x3e	; 62
	if(g_CallBackPtr0!=NULL)
    2956:	80 91 4d 01 	lds	r24, 0x014D
    295a:	90 91 4e 01 	lds	r25, 0x014E
    295e:	00 97       	sbiw	r24, 0x00	; 0
    2960:	29 f0       	breq	.+10     	; 0x296c <__vector_19+0x40>
	      {
		   (*g_CallBackPtr0)();
    2962:	e0 91 4d 01 	lds	r30, 0x014D
    2966:	f0 91 4e 01 	lds	r31, 0x014E
    296a:	09 95       	icall
	      }
}
    296c:	cf 91       	pop	r28
    296e:	df 91       	pop	r29
    2970:	ff 91       	pop	r31
    2972:	ef 91       	pop	r30
    2974:	bf 91       	pop	r27
    2976:	af 91       	pop	r26
    2978:	9f 91       	pop	r25
    297a:	8f 91       	pop	r24
    297c:	7f 91       	pop	r23
    297e:	6f 91       	pop	r22
    2980:	5f 91       	pop	r21
    2982:	4f 91       	pop	r20
    2984:	3f 91       	pop	r19
    2986:	2f 91       	pop	r18
    2988:	0f 90       	pop	r0
    298a:	0f be       	out	0x3f, r0	; 63
    298c:	0f 90       	pop	r0
    298e:	1f 90       	pop	r1
    2990:	18 95       	reti

00002992 <__vector_6>:

/*ISR for Timer 1  Compare mode */
ISR(TIMER1_COMPA_vect)
{
    2992:	1f 92       	push	r1
    2994:	0f 92       	push	r0
    2996:	0f b6       	in	r0, 0x3f	; 63
    2998:	0f 92       	push	r0
    299a:	11 24       	eor	r1, r1
    299c:	2f 93       	push	r18
    299e:	3f 93       	push	r19
    29a0:	4f 93       	push	r20
    29a2:	5f 93       	push	r21
    29a4:	6f 93       	push	r22
    29a6:	7f 93       	push	r23
    29a8:	8f 93       	push	r24
    29aa:	9f 93       	push	r25
    29ac:	af 93       	push	r26
    29ae:	bf 93       	push	r27
    29b0:	ef 93       	push	r30
    29b2:	ff 93       	push	r31
    29b4:	df 93       	push	r29
    29b6:	cf 93       	push	r28
    29b8:	cd b7       	in	r28, 0x3d	; 61
    29ba:	de b7       	in	r29, 0x3e	; 62
	if(g_CallBackPtr1!=NULL)
    29bc:	80 91 4f 01 	lds	r24, 0x014F
    29c0:	90 91 50 01 	lds	r25, 0x0150
    29c4:	00 97       	sbiw	r24, 0x00	; 0
    29c6:	29 f0       	breq	.+10     	; 0x29d2 <__vector_6+0x40>
	      {
		   (*g_CallBackPtr1)();
    29c8:	e0 91 4f 01 	lds	r30, 0x014F
    29cc:	f0 91 50 01 	lds	r31, 0x0150
    29d0:	09 95       	icall
	      }
}
    29d2:	cf 91       	pop	r28
    29d4:	df 91       	pop	r29
    29d6:	ff 91       	pop	r31
    29d8:	ef 91       	pop	r30
    29da:	bf 91       	pop	r27
    29dc:	af 91       	pop	r26
    29de:	9f 91       	pop	r25
    29e0:	8f 91       	pop	r24
    29e2:	7f 91       	pop	r23
    29e4:	6f 91       	pop	r22
    29e6:	5f 91       	pop	r21
    29e8:	4f 91       	pop	r20
    29ea:	3f 91       	pop	r19
    29ec:	2f 91       	pop	r18
    29ee:	0f 90       	pop	r0
    29f0:	0f be       	out	0x3f, r0	; 63
    29f2:	0f 90       	pop	r0
    29f4:	1f 90       	pop	r1
    29f6:	18 95       	reti

000029f8 <__vector_3>:

/*ISR for Timer 2  Compare mode */
ISR(TIMER2_COMP_vect)
{
    29f8:	1f 92       	push	r1
    29fa:	0f 92       	push	r0
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	0f 92       	push	r0
    2a00:	11 24       	eor	r1, r1
    2a02:	2f 93       	push	r18
    2a04:	3f 93       	push	r19
    2a06:	4f 93       	push	r20
    2a08:	5f 93       	push	r21
    2a0a:	6f 93       	push	r22
    2a0c:	7f 93       	push	r23
    2a0e:	8f 93       	push	r24
    2a10:	9f 93       	push	r25
    2a12:	af 93       	push	r26
    2a14:	bf 93       	push	r27
    2a16:	ef 93       	push	r30
    2a18:	ff 93       	push	r31
    2a1a:	df 93       	push	r29
    2a1c:	cf 93       	push	r28
    2a1e:	cd b7       	in	r28, 0x3d	; 61
    2a20:	de b7       	in	r29, 0x3e	; 62
	if(g_CallBackPtr2!=NULL)
    2a22:	80 91 51 01 	lds	r24, 0x0151
    2a26:	90 91 52 01 	lds	r25, 0x0152
    2a2a:	00 97       	sbiw	r24, 0x00	; 0
    2a2c:	29 f0       	breq	.+10     	; 0x2a38 <__vector_3+0x40>
	      {
		   (*g_CallBackPtr2)();
    2a2e:	e0 91 51 01 	lds	r30, 0x0151
    2a32:	f0 91 52 01 	lds	r31, 0x0152
    2a36:	09 95       	icall
	      }
}
    2a38:	cf 91       	pop	r28
    2a3a:	df 91       	pop	r29
    2a3c:	ff 91       	pop	r31
    2a3e:	ef 91       	pop	r30
    2a40:	bf 91       	pop	r27
    2a42:	af 91       	pop	r26
    2a44:	9f 91       	pop	r25
    2a46:	8f 91       	pop	r24
    2a48:	7f 91       	pop	r23
    2a4a:	6f 91       	pop	r22
    2a4c:	5f 91       	pop	r21
    2a4e:	4f 91       	pop	r20
    2a50:	3f 91       	pop	r19
    2a52:	2f 91       	pop	r18
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	0f 90       	pop	r0
    2a5a:	1f 90       	pop	r1
    2a5c:	18 95       	reti

00002a5e <TIMER_init>:



void TIMER_init(const TIMER_config  * configOfTimer  )
{
    2a5e:	df 93       	push	r29
    2a60:	cf 93       	push	r28
    2a62:	00 d0       	rcall	.+0      	; 0x2a64 <TIMER_init+0x6>
    2a64:	cd b7       	in	r28, 0x3d	; 61
    2a66:	de b7       	in	r29, 0x3e	; 62
    2a68:	9a 83       	std	Y+2, r25	; 0x02
    2a6a:	89 83       	std	Y+1, r24	; 0x01

	if(configOfTimer ->channel == timer1)
    2a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a70:	80 81       	ld	r24, Z
    2a72:	81 30       	cpi	r24, 0x01	; 1
    2a74:	29 f4       	brne	.+10     	; 0x2a80 <TIMER_init+0x22>
	{
		TIMER1_init(configOfTimer);
    2a76:	89 81       	ldd	r24, Y+1	; 0x01
    2a78:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7a:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <TIMER1_init>
    2a7e:	0e c0       	rjmp	.+28     	; 0x2a9c <TIMER_init+0x3e>
	}
	else if (configOfTimer ->channel == timer0)
    2a80:	e9 81       	ldd	r30, Y+1	; 0x01
    2a82:	fa 81       	ldd	r31, Y+2	; 0x02
    2a84:	80 81       	ld	r24, Z
    2a86:	88 23       	and	r24, r24
    2a88:	29 f4       	brne	.+10     	; 0x2a94 <TIMER_init+0x36>
	{
			TIMER0_init(configOfTimer);
    2a8a:	89 81       	ldd	r24, Y+1	; 0x01
    2a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a8e:	0e 94 53 15 	call	0x2aa6	; 0x2aa6 <TIMER0_init>
    2a92:	04 c0       	rjmp	.+8      	; 0x2a9c <TIMER_init+0x3e>
	}
	else
	{
		TIMER2_init(configOfTimer);
    2a94:	89 81       	ldd	r24, Y+1	; 0x01
    2a96:	9a 81       	ldd	r25, Y+2	; 0x02
    2a98:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <TIMER2_init>

	}
}
    2a9c:	0f 90       	pop	r0
    2a9e:	0f 90       	pop	r0
    2aa0:	cf 91       	pop	r28
    2aa2:	df 91       	pop	r29
    2aa4:	08 95       	ret

00002aa6 <TIMER0_init>:
 * 3. set Compare unit or display it
 * 4. Enable the Timer Interrupt.
 * 5.Set the required clock.
 */
static void TIMER0_init( const TIMER_config  * configOfTimer )
{
    2aa6:	df 93       	push	r29
    2aa8:	cf 93       	push	r28
    2aaa:	00 d0       	rcall	.+0      	; 0x2aac <TIMER0_init+0x6>
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
    2ab0:	9a 83       	std	Y+2, r25	; 0x02
    2ab2:	89 83       	std	Y+1, r24	; 0x01
	TCCR0 = (1<<FOC0) | (TCCR0 |  (configOfTimer ->waveMode.TIMER_0_2_waveMode <<WGM01 ) ) | (TCCR0 | (configOfTimer ->compOut ) <<COM00) |(TCCR0|configOfTimer->clock.Timer_0_1_clock);
    2ab4:	a3 e5       	ldi	r26, 0x53	; 83
    2ab6:	b0 e0       	ldi	r27, 0x00	; 0
    2ab8:	e3 e5       	ldi	r30, 0x53	; 83
    2aba:	f0 e0       	ldi	r31, 0x00	; 0
    2abc:	80 81       	ld	r24, Z
    2abe:	28 2f       	mov	r18, r24
    2ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac4:	82 81       	ldd	r24, Z+2	; 0x02
    2ac6:	88 2f       	mov	r24, r24
    2ac8:	90 e0       	ldi	r25, 0x00	; 0
    2aca:	88 0f       	add	r24, r24
    2acc:	99 1f       	adc	r25, r25
    2ace:	88 0f       	add	r24, r24
    2ad0:	99 1f       	adc	r25, r25
    2ad2:	88 0f       	add	r24, r24
    2ad4:	99 1f       	adc	r25, r25
    2ad6:	82 2b       	or	r24, r18
    2ad8:	28 2f       	mov	r18, r24
    2ada:	20 68       	ori	r18, 0x80	; 128
    2adc:	e3 e5       	ldi	r30, 0x53	; 83
    2ade:	f0 e0       	ldi	r31, 0x00	; 0
    2ae0:	80 81       	ld	r24, Z
    2ae2:	38 2f       	mov	r19, r24
    2ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae8:	81 81       	ldd	r24, Z+1	; 0x01
    2aea:	88 2f       	mov	r24, r24
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	82 95       	swap	r24
    2af0:	92 95       	swap	r25
    2af2:	90 7f       	andi	r25, 0xF0	; 240
    2af4:	98 27       	eor	r25, r24
    2af6:	80 7f       	andi	r24, 0xF0	; 240
    2af8:	98 27       	eor	r25, r24
    2afa:	83 2b       	or	r24, r19
    2afc:	28 2b       	or	r18, r24
    2afe:	e3 e5       	ldi	r30, 0x53	; 83
    2b00:	f0 e0       	ldi	r31, 0x00	; 0
    2b02:	90 81       	ld	r25, Z
    2b04:	e9 81       	ldd	r30, Y+1	; 0x01
    2b06:	fa 81       	ldd	r31, Y+2	; 0x02
    2b08:	83 81       	ldd	r24, Z+3	; 0x03
    2b0a:	89 2b       	or	r24, r25
    2b0c:	82 2b       	or	r24, r18
    2b0e:	8c 93       	st	X, r24
	TCNT0=configOfTimer->initalValue;
    2b10:	a2 e5       	ldi	r26, 0x52	; 82
    2b12:	b0 e0       	ldi	r27, 0x00	; 0
    2b14:	e9 81       	ldd	r30, Y+1	; 0x01
    2b16:	fa 81       	ldd	r31, Y+2	; 0x02
    2b18:	84 81       	ldd	r24, Z+4	; 0x04
    2b1a:	95 81       	ldd	r25, Z+5	; 0x05
    2b1c:	8c 93       	st	X, r24

	if (configOfTimer->waveMode.TIMER_0_2_waveMode == TIMER_0_2_Normal )
    2b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b20:	fa 81       	ldd	r31, Y+2	; 0x02
    2b22:	82 81       	ldd	r24, Z+2	; 0x02
    2b24:	88 23       	and	r24, r24
    2b26:	41 f4       	brne	.+16     	; 0x2b38 <TIMER0_init+0x92>
		TIMSK |= (1<<TOIE0);
    2b28:	a9 e5       	ldi	r26, 0x59	; 89
    2b2a:	b0 e0       	ldi	r27, 0x00	; 0
    2b2c:	e9 e5       	ldi	r30, 0x59	; 89
    2b2e:	f0 e0       	ldi	r31, 0x00	; 0
    2b30:	80 81       	ld	r24, Z
    2b32:	81 60       	ori	r24, 0x01	; 1
    2b34:	8c 93       	st	X, r24
    2b36:	13 c0       	rjmp	.+38     	; 0x2b5e <TIMER0_init+0xb8>

	else if (configOfTimer->waveMode.TIMER_0_2_waveMode== TIMER_0_2_CTC)
    2b38:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3c:	82 81       	ldd	r24, Z+2	; 0x02
    2b3e:	81 30       	cpi	r24, 0x01	; 1
    2b40:	71 f4       	brne	.+28     	; 0x2b5e <TIMER0_init+0xb8>
	{
		TIMSK |= (1<<OCIE0);
    2b42:	a9 e5       	ldi	r26, 0x59	; 89
    2b44:	b0 e0       	ldi	r27, 0x00	; 0
    2b46:	e9 e5       	ldi	r30, 0x59	; 89
    2b48:	f0 e0       	ldi	r31, 0x00	; 0
    2b4a:	80 81       	ld	r24, Z
    2b4c:	82 60       	ori	r24, 0x02	; 2
    2b4e:	8c 93       	st	X, r24
		OCR0 = configOfTimer->finalValue;
    2b50:	ac e5       	ldi	r26, 0x5C	; 92
    2b52:	b0 e0       	ldi	r27, 0x00	; 0
    2b54:	e9 81       	ldd	r30, Y+1	; 0x01
    2b56:	fa 81       	ldd	r31, Y+2	; 0x02
    2b58:	86 81       	ldd	r24, Z+6	; 0x06
    2b5a:	97 81       	ldd	r25, Z+7	; 0x07
    2b5c:	8c 93       	st	X, r24
	}
}
    2b5e:	0f 90       	pop	r0
    2b60:	0f 90       	pop	r0
    2b62:	cf 91       	pop	r28
    2b64:	df 91       	pop	r29
    2b66:	08 95       	ret

00002b68 <TIMER2_init>:


 static void TIMER2_init( const TIMER_config  * configOfTimer )
 {
    2b68:	df 93       	push	r29
    2b6a:	cf 93       	push	r28
    2b6c:	00 d0       	rcall	.+0      	; 0x2b6e <TIMER2_init+0x6>
    2b6e:	cd b7       	in	r28, 0x3d	; 61
    2b70:	de b7       	in	r29, 0x3e	; 62
    2b72:	9a 83       	std	Y+2, r25	; 0x02
    2b74:	89 83       	std	Y+1, r24	; 0x01
 	TCCR2 = (1<<FOC2) | (TCCR2 |  (configOfTimer ->waveMode.TIMER_0_2_waveMode <<WGM21 ) ) | (TCCR2 | (configOfTimer ->compOut) <<COM20) |(TCCR2|configOfTimer->clock.Timer_2_clock);
    2b76:	a5 e4       	ldi	r26, 0x45	; 69
    2b78:	b0 e0       	ldi	r27, 0x00	; 0
    2b7a:	e5 e4       	ldi	r30, 0x45	; 69
    2b7c:	f0 e0       	ldi	r31, 0x00	; 0
    2b7e:	80 81       	ld	r24, Z
    2b80:	28 2f       	mov	r18, r24
    2b82:	e9 81       	ldd	r30, Y+1	; 0x01
    2b84:	fa 81       	ldd	r31, Y+2	; 0x02
    2b86:	82 81       	ldd	r24, Z+2	; 0x02
    2b88:	88 2f       	mov	r24, r24
    2b8a:	90 e0       	ldi	r25, 0x00	; 0
    2b8c:	88 0f       	add	r24, r24
    2b8e:	99 1f       	adc	r25, r25
    2b90:	88 0f       	add	r24, r24
    2b92:	99 1f       	adc	r25, r25
    2b94:	88 0f       	add	r24, r24
    2b96:	99 1f       	adc	r25, r25
    2b98:	82 2b       	or	r24, r18
    2b9a:	28 2f       	mov	r18, r24
    2b9c:	20 68       	ori	r18, 0x80	; 128
    2b9e:	e5 e4       	ldi	r30, 0x45	; 69
    2ba0:	f0 e0       	ldi	r31, 0x00	; 0
    2ba2:	80 81       	ld	r24, Z
    2ba4:	38 2f       	mov	r19, r24
    2ba6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba8:	fa 81       	ldd	r31, Y+2	; 0x02
    2baa:	81 81       	ldd	r24, Z+1	; 0x01
    2bac:	88 2f       	mov	r24, r24
    2bae:	90 e0       	ldi	r25, 0x00	; 0
    2bb0:	82 95       	swap	r24
    2bb2:	92 95       	swap	r25
    2bb4:	90 7f       	andi	r25, 0xF0	; 240
    2bb6:	98 27       	eor	r25, r24
    2bb8:	80 7f       	andi	r24, 0xF0	; 240
    2bba:	98 27       	eor	r25, r24
    2bbc:	83 2b       	or	r24, r19
    2bbe:	28 2b       	or	r18, r24
    2bc0:	e5 e4       	ldi	r30, 0x45	; 69
    2bc2:	f0 e0       	ldi	r31, 0x00	; 0
    2bc4:	90 81       	ld	r25, Z
    2bc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2bca:	83 81       	ldd	r24, Z+3	; 0x03
    2bcc:	89 2b       	or	r24, r25
    2bce:	82 2b       	or	r24, r18
    2bd0:	8c 93       	st	X, r24
 	TCNT2=configOfTimer->initalValue;
    2bd2:	a4 e4       	ldi	r26, 0x44	; 68
    2bd4:	b0 e0       	ldi	r27, 0x00	; 0
    2bd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2bda:	84 81       	ldd	r24, Z+4	; 0x04
    2bdc:	95 81       	ldd	r25, Z+5	; 0x05
    2bde:	8c 93       	st	X, r24

 	if (configOfTimer->waveMode.TIMER_0_2_waveMode == TIMER_0_2_Normal )
    2be0:	e9 81       	ldd	r30, Y+1	; 0x01
    2be2:	fa 81       	ldd	r31, Y+2	; 0x02
    2be4:	82 81       	ldd	r24, Z+2	; 0x02
    2be6:	88 23       	and	r24, r24
    2be8:	41 f4       	brne	.+16     	; 0x2bfa <TIMER2_init+0x92>
 		TIMSK |= (1<<TOIE2);
    2bea:	a9 e5       	ldi	r26, 0x59	; 89
    2bec:	b0 e0       	ldi	r27, 0x00	; 0
    2bee:	e9 e5       	ldi	r30, 0x59	; 89
    2bf0:	f0 e0       	ldi	r31, 0x00	; 0
    2bf2:	80 81       	ld	r24, Z
    2bf4:	80 64       	ori	r24, 0x40	; 64
    2bf6:	8c 93       	st	X, r24
    2bf8:	13 c0       	rjmp	.+38     	; 0x2c20 <TIMER2_init+0xb8>

 	else if (configOfTimer->waveMode.TIMER_0_2_waveMode== TIMER_0_2_CTC)
    2bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bfe:	82 81       	ldd	r24, Z+2	; 0x02
    2c00:	81 30       	cpi	r24, 0x01	; 1
    2c02:	71 f4       	brne	.+28     	; 0x2c20 <TIMER2_init+0xb8>
 	{
 		TIMSK |= (1<<OCIE2);
    2c04:	a9 e5       	ldi	r26, 0x59	; 89
    2c06:	b0 e0       	ldi	r27, 0x00	; 0
    2c08:	e9 e5       	ldi	r30, 0x59	; 89
    2c0a:	f0 e0       	ldi	r31, 0x00	; 0
    2c0c:	80 81       	ld	r24, Z
    2c0e:	80 68       	ori	r24, 0x80	; 128
    2c10:	8c 93       	st	X, r24
 		OCR2 = configOfTimer->finalValue;
    2c12:	a3 e4       	ldi	r26, 0x43	; 67
    2c14:	b0 e0       	ldi	r27, 0x00	; 0
    2c16:	e9 81       	ldd	r30, Y+1	; 0x01
    2c18:	fa 81       	ldd	r31, Y+2	; 0x02
    2c1a:	86 81       	ldd	r24, Z+6	; 0x06
    2c1c:	97 81       	ldd	r25, Z+7	; 0x07
    2c1e:	8c 93       	st	X, r24
 	}
 }
    2c20:	0f 90       	pop	r0
    2c22:	0f 90       	pop	r0
    2c24:	cf 91       	pop	r28
    2c26:	df 91       	pop	r29
    2c28:	08 95       	ret

00002c2a <TIMER1_init>:


static void TIMER1_init( const TIMER_config  * configOfTimer )
{
    2c2a:	df 93       	push	r29
    2c2c:	cf 93       	push	r28
    2c2e:	00 d0       	rcall	.+0      	; 0x2c30 <TIMER1_init+0x6>
    2c30:	00 d0       	rcall	.+0      	; 0x2c32 <TIMER1_init+0x8>
    2c32:	cd b7       	in	r28, 0x3d	; 61
    2c34:	de b7       	in	r29, 0x3e	; 62
    2c36:	9a 83       	std	Y+2, r25	; 0x02
    2c38:	89 83       	std	Y+1, r24	; 0x01
	 * 3) we assign the value of the clock in TCCR1B register
	 * 4)assign initial value in TCNT1 register
	 * 6) Put the top value in OCR1A or  ICR1 in case of CTC mode
	 * 7) enable the suitable interrupt
	 */
	TCCR1A = (1<<FOC1A) |(1<<FOC1B) | ( TCCR1A | (configOfTimer->waveMode.TIMER1_waveMode &0x03) ) | (TCCR1A |(configOfTimer->compOut << COM1A0) ) ;
    2c3a:	af e4       	ldi	r26, 0x4F	; 79
    2c3c:	b0 e0       	ldi	r27, 0x00	; 0
    2c3e:	ef e4       	ldi	r30, 0x4F	; 79
    2c40:	f0 e0       	ldi	r31, 0x00	; 0
    2c42:	80 81       	ld	r24, Z
    2c44:	98 2f       	mov	r25, r24
    2c46:	e9 81       	ldd	r30, Y+1	; 0x01
    2c48:	fa 81       	ldd	r31, Y+2	; 0x02
    2c4a:	82 81       	ldd	r24, Z+2	; 0x02
    2c4c:	83 70       	andi	r24, 0x03	; 3
    2c4e:	89 2b       	or	r24, r25
    2c50:	28 2f       	mov	r18, r24
    2c52:	2c 60       	ori	r18, 0x0C	; 12
    2c54:	ef e4       	ldi	r30, 0x4F	; 79
    2c56:	f0 e0       	ldi	r31, 0x00	; 0
    2c58:	80 81       	ld	r24, Z
    2c5a:	38 2f       	mov	r19, r24
    2c5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c60:	81 81       	ldd	r24, Z+1	; 0x01
    2c62:	88 2f       	mov	r24, r24
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	00 24       	eor	r0, r0
    2c68:	96 95       	lsr	r25
    2c6a:	87 95       	ror	r24
    2c6c:	07 94       	ror	r0
    2c6e:	96 95       	lsr	r25
    2c70:	87 95       	ror	r24
    2c72:	07 94       	ror	r0
    2c74:	98 2f       	mov	r25, r24
    2c76:	80 2d       	mov	r24, r0
    2c78:	83 2b       	or	r24, r19
    2c7a:	82 2b       	or	r24, r18
    2c7c:	8c 93       	st	X, r24
	TCCR1B = ( TCCR1B | ( (configOfTimer->waveMode.TIMER1_waveMode &0x0C) <<1 ) ) |(TCCR1B | configOfTimer->clock.Timer_0_1_clock);
    2c7e:	ae e4       	ldi	r26, 0x4E	; 78
    2c80:	b0 e0       	ldi	r27, 0x00	; 0
    2c82:	ee e4       	ldi	r30, 0x4E	; 78
    2c84:	f0 e0       	ldi	r31, 0x00	; 0
    2c86:	80 81       	ld	r24, Z
    2c88:	28 2f       	mov	r18, r24
    2c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c8e:	82 81       	ldd	r24, Z+2	; 0x02
    2c90:	88 2f       	mov	r24, r24
    2c92:	90 e0       	ldi	r25, 0x00	; 0
    2c94:	8c 70       	andi	r24, 0x0C	; 12
    2c96:	90 70       	andi	r25, 0x00	; 0
    2c98:	88 0f       	add	r24, r24
    2c9a:	99 1f       	adc	r25, r25
    2c9c:	28 2b       	or	r18, r24
    2c9e:	ee e4       	ldi	r30, 0x4E	; 78
    2ca0:	f0 e0       	ldi	r31, 0x00	; 0
    2ca2:	90 81       	ld	r25, Z
    2ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca8:	83 81       	ldd	r24, Z+3	; 0x03
    2caa:	89 2b       	or	r24, r25
    2cac:	82 2b       	or	r24, r18
    2cae:	8c 93       	st	X, r24
	TCNT1=configOfTimer->initalValue;
    2cb0:	ac e4       	ldi	r26, 0x4C	; 76
    2cb2:	b0 e0       	ldi	r27, 0x00	; 0
    2cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    2cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    2cb8:	84 81       	ldd	r24, Z+4	; 0x04
    2cba:	95 81       	ldd	r25, Z+5	; 0x05
    2cbc:	11 96       	adiw	r26, 0x01	; 1
    2cbe:	9c 93       	st	X, r25
    2cc0:	8e 93       	st	-X, r24

	switch (configOfTimer->waveMode.TIMER1_waveMode)
    2cc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2cc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2cc6:	82 81       	ldd	r24, Z+2	; 0x02
    2cc8:	28 2f       	mov	r18, r24
    2cca:	30 e0       	ldi	r19, 0x00	; 0
    2ccc:	3c 83       	std	Y+4, r19	; 0x04
    2cce:	2b 83       	std	Y+3, r18	; 0x03
    2cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd4:	84 30       	cpi	r24, 0x04	; 4
    2cd6:	91 05       	cpc	r25, r1
    2cd8:	89 f0       	breq	.+34     	; 0x2cfc <TIMER1_init+0xd2>
    2cda:	2b 81       	ldd	r18, Y+3	; 0x03
    2cdc:	3c 81       	ldd	r19, Y+4	; 0x04
    2cde:	2c 30       	cpi	r18, 0x0C	; 12
    2ce0:	31 05       	cpc	r19, r1
    2ce2:	e9 f0       	breq	.+58     	; 0x2d1e <TIMER1_init+0xf4>
    2ce4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce8:	00 97       	sbiw	r24, 0x00	; 0
    2cea:	49 f5       	brne	.+82     	; 0x2d3e <TIMER1_init+0x114>
	{
		case TIMER1_Normal: TIMSK |= (1<<TOIE1); break; // OCR1A VALUE ??
    2cec:	a9 e5       	ldi	r26, 0x59	; 89
    2cee:	b0 e0       	ldi	r27, 0x00	; 0
    2cf0:	e9 e5       	ldi	r30, 0x59	; 89
    2cf2:	f0 e0       	ldi	r31, 0x00	; 0
    2cf4:	80 81       	ld	r24, Z
    2cf6:	84 60       	ori	r24, 0x04	; 4
    2cf8:	8c 93       	st	X, r24
    2cfa:	21 c0       	rjmp	.+66     	; 0x2d3e <TIMER1_init+0x114>

		case TIMER1_CTC_OCR1A : OCR1A = configOfTimer->finalValue;
    2cfc:	aa e4       	ldi	r26, 0x4A	; 74
    2cfe:	b0 e0       	ldi	r27, 0x00	; 0
    2d00:	e9 81       	ldd	r30, Y+1	; 0x01
    2d02:	fa 81       	ldd	r31, Y+2	; 0x02
    2d04:	86 81       	ldd	r24, Z+6	; 0x06
    2d06:	97 81       	ldd	r25, Z+7	; 0x07
    2d08:	11 96       	adiw	r26, 0x01	; 1
    2d0a:	9c 93       	st	X, r25
    2d0c:	8e 93       	st	-X, r24
								TIMSK |= (1<<OCIE1A); break;
    2d0e:	a9 e5       	ldi	r26, 0x59	; 89
    2d10:	b0 e0       	ldi	r27, 0x00	; 0
    2d12:	e9 e5       	ldi	r30, 0x59	; 89
    2d14:	f0 e0       	ldi	r31, 0x00	; 0
    2d16:	80 81       	ld	r24, Z
    2d18:	80 61       	ori	r24, 0x10	; 16
    2d1a:	8c 93       	st	X, r24
    2d1c:	10 c0       	rjmp	.+32     	; 0x2d3e <TIMER1_init+0x114>

		case TIMER1_CTC_ICR1 :  ICR1 = configOfTimer->finalValue;
    2d1e:	a6 e4       	ldi	r26, 0x46	; 70
    2d20:	b0 e0       	ldi	r27, 0x00	; 0
    2d22:	e9 81       	ldd	r30, Y+1	; 0x01
    2d24:	fa 81       	ldd	r31, Y+2	; 0x02
    2d26:	86 81       	ldd	r24, Z+6	; 0x06
    2d28:	97 81       	ldd	r25, Z+7	; 0x07
    2d2a:	11 96       	adiw	r26, 0x01	; 1
    2d2c:	9c 93       	st	X, r25
    2d2e:	8e 93       	st	-X, r24
								TIMSK |= (1<<OCIE1A); break;
    2d30:	a9 e5       	ldi	r26, 0x59	; 89
    2d32:	b0 e0       	ldi	r27, 0x00	; 0
    2d34:	e9 e5       	ldi	r30, 0x59	; 89
    2d36:	f0 e0       	ldi	r31, 0x00	; 0
    2d38:	80 81       	ld	r24, Z
    2d3a:	80 61       	ori	r24, 0x10	; 16
    2d3c:	8c 93       	st	X, r24

	}

}
    2d3e:	0f 90       	pop	r0
    2d40:	0f 90       	pop	r0
    2d42:	0f 90       	pop	r0
    2d44:	0f 90       	pop	r0
    2d46:	cf 91       	pop	r28
    2d48:	df 91       	pop	r29
    2d4a:	08 95       	ret

00002d4c <Timer0_setCallBack>:
/*
 * Description: Function to set the Call Back function address.
 */
void Timer0_setCallBack(void(*ptr0Func)(void))

{
    2d4c:	df 93       	push	r29
    2d4e:	cf 93       	push	r28
    2d50:	00 d0       	rcall	.+0      	; 0x2d52 <Timer0_setCallBack+0x6>
    2d52:	cd b7       	in	r28, 0x3d	; 61
    2d54:	de b7       	in	r29, 0x3e	; 62
    2d56:	9a 83       	std	Y+2, r25	; 0x02
    2d58:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
  g_CallBackPtr0=ptr0Func;
    2d5a:	89 81       	ldd	r24, Y+1	; 0x01
    2d5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d5e:	90 93 4e 01 	sts	0x014E, r25
    2d62:	80 93 4d 01 	sts	0x014D, r24

}
    2d66:	0f 90       	pop	r0
    2d68:	0f 90       	pop	r0
    2d6a:	cf 91       	pop	r28
    2d6c:	df 91       	pop	r29
    2d6e:	08 95       	ret

00002d70 <Timer1_setCallBack>:
void Timer1_setCallBack(void(*ptr1Func)(void))

{
    2d70:	df 93       	push	r29
    2d72:	cf 93       	push	r28
    2d74:	00 d0       	rcall	.+0      	; 0x2d76 <Timer1_setCallBack+0x6>
    2d76:	cd b7       	in	r28, 0x3d	; 61
    2d78:	de b7       	in	r29, 0x3e	; 62
    2d7a:	9a 83       	std	Y+2, r25	; 0x02
    2d7c:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
  g_CallBackPtr1=ptr1Func;
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
    2d80:	9a 81       	ldd	r25, Y+2	; 0x02
    2d82:	90 93 50 01 	sts	0x0150, r25
    2d86:	80 93 4f 01 	sts	0x014F, r24

}
    2d8a:	0f 90       	pop	r0
    2d8c:	0f 90       	pop	r0
    2d8e:	cf 91       	pop	r28
    2d90:	df 91       	pop	r29
    2d92:	08 95       	ret

00002d94 <Timer2_setCallBack>:
void Timer2_setCallBack(void(*ptr2Func)(void))

{
    2d94:	df 93       	push	r29
    2d96:	cf 93       	push	r28
    2d98:	00 d0       	rcall	.+0      	; 0x2d9a <Timer2_setCallBack+0x6>
    2d9a:	cd b7       	in	r28, 0x3d	; 61
    2d9c:	de b7       	in	r29, 0x3e	; 62
    2d9e:	9a 83       	std	Y+2, r25	; 0x02
    2da0:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
  g_CallBackPtr2=ptr2Func;
    2da2:	89 81       	ldd	r24, Y+1	; 0x01
    2da4:	9a 81       	ldd	r25, Y+2	; 0x02
    2da6:	90 93 52 01 	sts	0x0152, r25
    2daa:	80 93 51 01 	sts	0x0151, r24
}
    2dae:	0f 90       	pop	r0
    2db0:	0f 90       	pop	r0
    2db2:	cf 91       	pop	r28
    2db4:	df 91       	pop	r29
    2db6:	08 95       	ret

00002db8 <TIMER1_stop>:

void TIMER1_stop()
{
    2db8:	df 93       	push	r29
    2dba:	cf 93       	push	r28
    2dbc:	cd b7       	in	r28, 0x3d	; 61
    2dbe:	de b7       	in	r29, 0x3e	; 62
	TCCR1B &= ~(1<<CS10) & ~(1<<CS10) & ~(1<<CS10);
    2dc0:	ae e4       	ldi	r26, 0x4E	; 78
    2dc2:	b0 e0       	ldi	r27, 0x00	; 0
    2dc4:	ee e4       	ldi	r30, 0x4E	; 78
    2dc6:	f0 e0       	ldi	r31, 0x00	; 0
    2dc8:	80 81       	ld	r24, Z
    2dca:	8e 7f       	andi	r24, 0xFE	; 254
    2dcc:	8c 93       	st	X, r24
}
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <USART_init>:
}
#endif


void USART_init(const usart_configType * a_configrations)
{
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	00 d0       	rcall	.+0      	; 0x2dda <USART_init+0x6>
    2dda:	cd b7       	in	r28, 0x3d	; 61
    2ddc:	de b7       	in	r29, 0x3e	; 62
    2dde:	9a 83       	std	Y+2, r25	; 0x02
    2de0:	89 83       	std	Y+1, r24	; 0x01
	/* we work on double speed mode */
	SET_BIT( UCSRA  , U2X);  	/* UCSRA|=(1<<USX); */
    2de2:	ab e2       	ldi	r26, 0x2B	; 43
    2de4:	b0 e0       	ldi	r27, 0x00	; 0
    2de6:	eb e2       	ldi	r30, 0x2B	; 43
    2de8:	f0 e0       	ldi	r31, 0x00	; 0
    2dea:	80 81       	ld	r24, Z
    2dec:	82 60       	ori	r24, 0x02	; 2
    2dee:	8c 93       	st	X, r24
		UCSRB|=(a_configrations->RX_or_TX << TXCIE);
	 }
	#endif

	 /* clear register to make sure that every bit =0 before assign any value on it */
	UCSRB=0; UCSRC=0;
    2df0:	ea e2       	ldi	r30, 0x2A	; 42
    2df2:	f0 e0       	ldi	r31, 0x00	; 0
    2df4:	10 82       	st	Z, r1
    2df6:	e0 e4       	ldi	r30, 0x40	; 64
    2df8:	f0 e0       	ldi	r31, 0x00	; 0
    2dfa:	10 82       	st	Z, r1

	/* enable TX or RX or Both */
	UCSRB |=(a_configrations->RX_or_TX << TXEN);
    2dfc:	aa e2       	ldi	r26, 0x2A	; 42
    2dfe:	b0 e0       	ldi	r27, 0x00	; 0
    2e00:	ea e2       	ldi	r30, 0x2A	; 42
    2e02:	f0 e0       	ldi	r31, 0x00	; 0
    2e04:	80 81       	ld	r24, Z
    2e06:	28 2f       	mov	r18, r24
    2e08:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0c:	83 81       	ldd	r24, Z+3	; 0x03
    2e0e:	88 2f       	mov	r24, r24
    2e10:	90 e0       	ldi	r25, 0x00	; 0
    2e12:	88 0f       	add	r24, r24
    2e14:	99 1f       	adc	r25, r25
    2e16:	88 0f       	add	r24, r24
    2e18:	99 1f       	adc	r25, r25
    2e1a:	88 0f       	add	r24, r24
    2e1c:	99 1f       	adc	r25, r25
    2e1e:	82 2b       	or	r24, r18
    2e20:	8c 93       	st	X, r24
	 * USBS    = number of stop bits
	 * UCSZ1:0 = number of bits data mode
	 * UCPOL   = 0 Used with the Synchronous operation only
	 ***********************************************************************/
	/* ex : UCSRC=(UCSRC& 0XF9)| (1 << UCSZ0) */
	 UCSRC |= (1<<URSEL)|(a_configrations->numOfBits << UCSZ0)|(a_configrations->parityBit <<UPM0)|(a_configrations->numOfstopBit <<USBS);
    2e22:	a0 e4       	ldi	r26, 0x40	; 64
    2e24:	b0 e0       	ldi	r27, 0x00	; 0
    2e26:	e0 e4       	ldi	r30, 0x40	; 64
    2e28:	f0 e0       	ldi	r31, 0x00	; 0
    2e2a:	80 81       	ld	r24, Z
    2e2c:	38 2f       	mov	r19, r24
    2e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e30:	fa 81       	ldd	r31, Y+2	; 0x02
    2e32:	80 81       	ld	r24, Z
    2e34:	88 2f       	mov	r24, r24
    2e36:	90 e0       	ldi	r25, 0x00	; 0
    2e38:	88 0f       	add	r24, r24
    2e3a:	99 1f       	adc	r25, r25
    2e3c:	28 2f       	mov	r18, r24
    2e3e:	20 68       	ori	r18, 0x80	; 128
    2e40:	e9 81       	ldd	r30, Y+1	; 0x01
    2e42:	fa 81       	ldd	r31, Y+2	; 0x02
    2e44:	81 81       	ldd	r24, Z+1	; 0x01
    2e46:	88 2f       	mov	r24, r24
    2e48:	90 e0       	ldi	r25, 0x00	; 0
    2e4a:	82 95       	swap	r24
    2e4c:	92 95       	swap	r25
    2e4e:	90 7f       	andi	r25, 0xF0	; 240
    2e50:	98 27       	eor	r25, r24
    2e52:	80 7f       	andi	r24, 0xF0	; 240
    2e54:	98 27       	eor	r25, r24
    2e56:	28 2b       	or	r18, r24
    2e58:	e9 81       	ldd	r30, Y+1	; 0x01
    2e5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e5c:	82 81       	ldd	r24, Z+2	; 0x02
    2e5e:	88 2f       	mov	r24, r24
    2e60:	90 e0       	ldi	r25, 0x00	; 0
    2e62:	88 0f       	add	r24, r24
    2e64:	99 1f       	adc	r25, r25
    2e66:	88 0f       	add	r24, r24
    2e68:	99 1f       	adc	r25, r25
    2e6a:	88 0f       	add	r24, r24
    2e6c:	99 1f       	adc	r25, r25
    2e6e:	82 2b       	or	r24, r18
    2e70:	83 2b       	or	r24, r19
    2e72:	8c 93       	st	X, r24

	 if (a_configrations->modeSelect == Synchronous) // if work on synchronous mode
    2e74:	e9 81       	ldd	r30, Y+1	; 0x01
    2e76:	fa 81       	ldd	r31, Y+2	; 0x02
    2e78:	84 81       	ldd	r24, Z+4	; 0x04
    2e7a:	81 30       	cpi	r24, 0x01	; 1
    2e7c:	39 f4       	brne	.+14     	; 0x2e8c <USART_init+0xb8>
		 UCSRC|= (1<<UMSEL);
    2e7e:	a0 e4       	ldi	r26, 0x40	; 64
    2e80:	b0 e0       	ldi	r27, 0x00	; 0
    2e82:	e0 e4       	ldi	r30, 0x40	; 64
    2e84:	f0 e0       	ldi	r31, 0x00	; 0
    2e86:	80 81       	ld	r24, Z
    2e88:	80 64       	ori	r24, 0x40	; 64
    2e8a:	8c 93       	st	X, r24

	 /* Adjust the baud rate  */
	 UBRRH = BAUDRATE_PRESCALE >>8;
    2e8c:	e0 e4       	ldi	r30, 0x40	; 64
    2e8e:	f0 e0       	ldi	r31, 0x00	; 0
    2e90:	10 82       	st	Z, r1
	 UBRRL=BAUDRATE_PRESCALE;
    2e92:	e9 e2       	ldi	r30, 0x29	; 41
    2e94:	f0 e0       	ldi	r31, 0x00	; 0
    2e96:	8c e0       	ldi	r24, 0x0C	; 12
    2e98:	80 83       	st	Z, r24

}
    2e9a:	0f 90       	pop	r0
    2e9c:	0f 90       	pop	r0
    2e9e:	cf 91       	pop	r28
    2ea0:	df 91       	pop	r29
    2ea2:	08 95       	ret

00002ea4 <USART_sendByte>:

void USART_sendByte(const uint8 data)
{
    2ea4:	df 93       	push	r29
    2ea6:	cf 93       	push	r28
    2ea8:	0f 92       	push	r0
    2eaa:	cd b7       	in	r28, 0x3d	; 61
    2eac:	de b7       	in	r29, 0x3e	; 62
    2eae:	89 83       	std	Y+1, r24	; 0x01
	/* *****************steps *********************
	 * Loop until the previous data all transmitted
	 * put the new data in the UDR to be transmitted
	 * when data i put in UDR then the UDRE is cleared automatic
	 * ******************************************** */
	while (BIT_IS_CLEAR(UCSRA , UDRE));
    2eb0:	eb e2       	ldi	r30, 0x2B	; 43
    2eb2:	f0 e0       	ldi	r31, 0x00	; 0
    2eb4:	80 81       	ld	r24, Z
    2eb6:	88 2f       	mov	r24, r24
    2eb8:	90 e0       	ldi	r25, 0x00	; 0
    2eba:	80 72       	andi	r24, 0x20	; 32
    2ebc:	90 70       	andi	r25, 0x00	; 0
    2ebe:	00 97       	sbiw	r24, 0x00	; 0
    2ec0:	b9 f3       	breq	.-18     	; 0x2eb0 <USART_sendByte+0xc>
	UDR= data;
    2ec2:	ec e2       	ldi	r30, 0x2C	; 44
    2ec4:	f0 e0       	ldi	r31, 0x00	; 0
    2ec6:	89 81       	ldd	r24, Y+1	; 0x01
    2ec8:	80 83       	st	Z, r24
	   UDR =data;
	   while(BIT_IS_CLEAR(UCSRA , TXC);
	   SET_BIT(UCSRA,TXC); // Clear the TXC flag
	 *************************************************/
	#endif
}
    2eca:	0f 90       	pop	r0
    2ecc:	cf 91       	pop	r28
    2ece:	df 91       	pop	r29
    2ed0:	08 95       	ret

00002ed2 <USART_recieveByte>:
uint8 USART_recieveByte(void)
{
    2ed2:	df 93       	push	r29
    2ed4:	cf 93       	push	r28
    2ed6:	cd b7       	in	r28, 0x3d	; 61
    2ed8:	de b7       	in	r29, 0x3e	; 62
#else
	/* *****************steps *********************
	 * Loop until the data are received
	 * then return the UDR which contain the data
	 * ******************************************** */
	while(BIT_IS_CLEAR(UCSRA , RXC));
    2eda:	eb e2       	ldi	r30, 0x2B	; 43
    2edc:	f0 e0       	ldi	r31, 0x00	; 0
    2ede:	80 81       	ld	r24, Z
    2ee0:	88 23       	and	r24, r24
    2ee2:	dc f7       	brge	.-10     	; 0x2eda <USART_recieveByte+0x8>
	return UDR;
    2ee4:	ec e2       	ldi	r30, 0x2C	; 44
    2ee6:	f0 e0       	ldi	r31, 0x00	; 0
    2ee8:	80 81       	ld	r24, Z
#endif
}
    2eea:	cf 91       	pop	r28
    2eec:	df 91       	pop	r29
    2eee:	08 95       	ret

00002ef0 <USART_sendString>:

void USART_sendString(const uint8 *str)
{
    2ef0:	df 93       	push	r29
    2ef2:	cf 93       	push	r28
    2ef4:	00 d0       	rcall	.+0      	; 0x2ef6 <USART_sendString+0x6>
    2ef6:	0f 92       	push	r0
    2ef8:	cd b7       	in	r28, 0x3d	; 61
    2efa:	de b7       	in	r29, 0x3e	; 62
    2efc:	9b 83       	std	Y+3, r25	; 0x03
    2efe:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i=0;
    2f00:	19 82       	std	Y+1, r1	; 0x01
    2f02:	0e c0       	rjmp	.+28     	; 0x2f20 <USART_sendString+0x30>
	while(str[i] !='\0')
	{
		USART_sendByte(str[i]);
    2f04:	89 81       	ldd	r24, Y+1	; 0x01
    2f06:	28 2f       	mov	r18, r24
    2f08:	30 e0       	ldi	r19, 0x00	; 0
    2f0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f0e:	fc 01       	movw	r30, r24
    2f10:	e2 0f       	add	r30, r18
    2f12:	f3 1f       	adc	r31, r19
    2f14:	80 81       	ld	r24, Z
    2f16:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <USART_sendByte>
		i++;
    2f1a:	89 81       	ldd	r24, Y+1	; 0x01
    2f1c:	8f 5f       	subi	r24, 0xFF	; 255
    2f1e:	89 83       	std	Y+1, r24	; 0x01
}

void USART_sendString(const uint8 *str)
{
	uint8 i=0;
	while(str[i] !='\0')
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	28 2f       	mov	r18, r24
    2f24:	30 e0       	ldi	r19, 0x00	; 0
    2f26:	8a 81       	ldd	r24, Y+2	; 0x02
    2f28:	9b 81       	ldd	r25, Y+3	; 0x03
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	e2 0f       	add	r30, r18
    2f2e:	f3 1f       	adc	r31, r19
    2f30:	80 81       	ld	r24, Z
    2f32:	88 23       	and	r24, r24
    2f34:	39 f7       	brne	.-50     	; 0x2f04 <USART_sendString+0x14>
	{
		UART_sendByte(*str);
		str++;
	}
	*******************************************************************/
}
    2f36:	0f 90       	pop	r0
    2f38:	0f 90       	pop	r0
    2f3a:	0f 90       	pop	r0
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	08 95       	ret

00002f42 <USART_receiveString>:
void USART_receiveString(uint8 *str) /* Receive until #*/
{
    2f42:	0f 93       	push	r16
    2f44:	1f 93       	push	r17
    2f46:	df 93       	push	r29
    2f48:	cf 93       	push	r28
    2f4a:	00 d0       	rcall	.+0      	; 0x2f4c <USART_receiveString+0xa>
    2f4c:	0f 92       	push	r0
    2f4e:	cd b7       	in	r28, 0x3d	; 61
    2f50:	de b7       	in	r29, 0x3e	; 62
    2f52:	9b 83       	std	Y+3, r25	; 0x03
    2f54:	8a 83       	std	Y+2, r24	; 0x02
	/* in USART we send the string with # in last character of the string
	 * so we recieve the string until #and replace it with null '\0' */
	uint8 i=-1;
    2f56:	8f ef       	ldi	r24, 0xFF	; 255
    2f58:	89 83       	std	Y+1, r24	; 0x01
	do
	{
		i++;
    2f5a:	89 81       	ldd	r24, Y+1	; 0x01
    2f5c:	8f 5f       	subi	r24, 0xFF	; 255
    2f5e:	89 83       	std	Y+1, r24	; 0x01
		str[i]=USART_recieveByte();
    2f60:	89 81       	ldd	r24, Y+1	; 0x01
    2f62:	28 2f       	mov	r18, r24
    2f64:	30 e0       	ldi	r19, 0x00	; 0
    2f66:	8a 81       	ldd	r24, Y+2	; 0x02
    2f68:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6a:	8c 01       	movw	r16, r24
    2f6c:	02 0f       	add	r16, r18
    2f6e:	13 1f       	adc	r17, r19
    2f70:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <USART_recieveByte>
    2f74:	f8 01       	movw	r30, r16
    2f76:	80 83       	st	Z, r24
	}while (str[i] !='#');
    2f78:	89 81       	ldd	r24, Y+1	; 0x01
    2f7a:	28 2f       	mov	r18, r24
    2f7c:	30 e0       	ldi	r19, 0x00	; 0
    2f7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f80:	9b 81       	ldd	r25, Y+3	; 0x03
    2f82:	fc 01       	movw	r30, r24
    2f84:	e2 0f       	add	r30, r18
    2f86:	f3 1f       	adc	r31, r19
    2f88:	80 81       	ld	r24, Z
    2f8a:	83 32       	cpi	r24, 0x23	; 35
    2f8c:	31 f7       	brne	.-52     	; 0x2f5a <USART_receiveString+0x18>

	/* add the null at last of string */
	str[i]='\0';
    2f8e:	89 81       	ldd	r24, Y+1	; 0x01
    2f90:	28 2f       	mov	r18, r24
    2f92:	30 e0       	ldi	r19, 0x00	; 0
    2f94:	8a 81       	ldd	r24, Y+2	; 0x02
    2f96:	9b 81       	ldd	r25, Y+3	; 0x03
    2f98:	fc 01       	movw	r30, r24
    2f9a:	e2 0f       	add	r30, r18
    2f9c:	f3 1f       	adc	r31, r19
    2f9e:	10 82       	st	Z, r1
}
    2fa0:	0f 90       	pop	r0
    2fa2:	0f 90       	pop	r0
    2fa4:	0f 90       	pop	r0
    2fa6:	cf 91       	pop	r28
    2fa8:	df 91       	pop	r29
    2faa:	1f 91       	pop	r17
    2fac:	0f 91       	pop	r16
    2fae:	08 95       	ret

00002fb0 <__prologue_saves__>:
    2fb0:	2f 92       	push	r2
    2fb2:	3f 92       	push	r3
    2fb4:	4f 92       	push	r4
    2fb6:	5f 92       	push	r5
    2fb8:	6f 92       	push	r6
    2fba:	7f 92       	push	r7
    2fbc:	8f 92       	push	r8
    2fbe:	9f 92       	push	r9
    2fc0:	af 92       	push	r10
    2fc2:	bf 92       	push	r11
    2fc4:	cf 92       	push	r12
    2fc6:	df 92       	push	r13
    2fc8:	ef 92       	push	r14
    2fca:	ff 92       	push	r15
    2fcc:	0f 93       	push	r16
    2fce:	1f 93       	push	r17
    2fd0:	cf 93       	push	r28
    2fd2:	df 93       	push	r29
    2fd4:	cd b7       	in	r28, 0x3d	; 61
    2fd6:	de b7       	in	r29, 0x3e	; 62
    2fd8:	ca 1b       	sub	r28, r26
    2fda:	db 0b       	sbc	r29, r27
    2fdc:	0f b6       	in	r0, 0x3f	; 63
    2fde:	f8 94       	cli
    2fe0:	de bf       	out	0x3e, r29	; 62
    2fe2:	0f be       	out	0x3f, r0	; 63
    2fe4:	cd bf       	out	0x3d, r28	; 61
    2fe6:	09 94       	ijmp

00002fe8 <__epilogue_restores__>:
    2fe8:	2a 88       	ldd	r2, Y+18	; 0x12
    2fea:	39 88       	ldd	r3, Y+17	; 0x11
    2fec:	48 88       	ldd	r4, Y+16	; 0x10
    2fee:	5f 84       	ldd	r5, Y+15	; 0x0f
    2ff0:	6e 84       	ldd	r6, Y+14	; 0x0e
    2ff2:	7d 84       	ldd	r7, Y+13	; 0x0d
    2ff4:	8c 84       	ldd	r8, Y+12	; 0x0c
    2ff6:	9b 84       	ldd	r9, Y+11	; 0x0b
    2ff8:	aa 84       	ldd	r10, Y+10	; 0x0a
    2ffa:	b9 84       	ldd	r11, Y+9	; 0x09
    2ffc:	c8 84       	ldd	r12, Y+8	; 0x08
    2ffe:	df 80       	ldd	r13, Y+7	; 0x07
    3000:	ee 80       	ldd	r14, Y+6	; 0x06
    3002:	fd 80       	ldd	r15, Y+5	; 0x05
    3004:	0c 81       	ldd	r16, Y+4	; 0x04
    3006:	1b 81       	ldd	r17, Y+3	; 0x03
    3008:	aa 81       	ldd	r26, Y+2	; 0x02
    300a:	b9 81       	ldd	r27, Y+1	; 0x01
    300c:	ce 0f       	add	r28, r30
    300e:	d1 1d       	adc	r29, r1
    3010:	0f b6       	in	r0, 0x3f	; 63
    3012:	f8 94       	cli
    3014:	de bf       	out	0x3e, r29	; 62
    3016:	0f be       	out	0x3f, r0	; 63
    3018:	cd bf       	out	0x3d, r28	; 61
    301a:	ed 01       	movw	r28, r26
    301c:	08 95       	ret

0000301e <strcmp>:
    301e:	fb 01       	movw	r30, r22
    3020:	dc 01       	movw	r26, r24
    3022:	8d 91       	ld	r24, X+
    3024:	01 90       	ld	r0, Z+
    3026:	80 19       	sub	r24, r0
    3028:	01 10       	cpse	r0, r1
    302a:	d9 f3       	breq	.-10     	; 0x3022 <strcmp+0x4>
    302c:	99 0b       	sbc	r25, r25
    302e:	08 95       	ret

00003030 <itoa>:
    3030:	fb 01       	movw	r30, r22
    3032:	9f 01       	movw	r18, r30
    3034:	e8 94       	clt
    3036:	42 30       	cpi	r20, 0x02	; 2
    3038:	c4 f0       	brlt	.+48     	; 0x306a <itoa+0x3a>
    303a:	45 32       	cpi	r20, 0x25	; 37
    303c:	b4 f4       	brge	.+44     	; 0x306a <itoa+0x3a>
    303e:	4a 30       	cpi	r20, 0x0A	; 10
    3040:	29 f4       	brne	.+10     	; 0x304c <itoa+0x1c>
    3042:	97 fb       	bst	r25, 7
    3044:	1e f4       	brtc	.+6      	; 0x304c <itoa+0x1c>
    3046:	90 95       	com	r25
    3048:	81 95       	neg	r24
    304a:	9f 4f       	sbci	r25, 0xFF	; 255
    304c:	64 2f       	mov	r22, r20
    304e:	77 27       	eor	r23, r23
    3050:	0e 94 49 18 	call	0x3092	; 0x3092 <__udivmodhi4>
    3054:	80 5d       	subi	r24, 0xD0	; 208
    3056:	8a 33       	cpi	r24, 0x3A	; 58
    3058:	0c f0       	brlt	.+2      	; 0x305c <itoa+0x2c>
    305a:	89 5d       	subi	r24, 0xD9	; 217
    305c:	81 93       	st	Z+, r24
    305e:	cb 01       	movw	r24, r22
    3060:	00 97       	sbiw	r24, 0x00	; 0
    3062:	a1 f7       	brne	.-24     	; 0x304c <itoa+0x1c>
    3064:	16 f4       	brtc	.+4      	; 0x306a <itoa+0x3a>
    3066:	5d e2       	ldi	r21, 0x2D	; 45
    3068:	51 93       	st	Z+, r21
    306a:	10 82       	st	Z, r1
    306c:	c9 01       	movw	r24, r18
    306e:	0c 94 39 18 	jmp	0x3072	; 0x3072 <strrev>

00003072 <strrev>:
    3072:	dc 01       	movw	r26, r24
    3074:	fc 01       	movw	r30, r24
    3076:	67 2f       	mov	r22, r23
    3078:	71 91       	ld	r23, Z+
    307a:	77 23       	and	r23, r23
    307c:	e1 f7       	brne	.-8      	; 0x3076 <strrev+0x4>
    307e:	32 97       	sbiw	r30, 0x02	; 2
    3080:	04 c0       	rjmp	.+8      	; 0x308a <strrev+0x18>
    3082:	7c 91       	ld	r23, X
    3084:	6d 93       	st	X+, r22
    3086:	70 83       	st	Z, r23
    3088:	62 91       	ld	r22, -Z
    308a:	ae 17       	cp	r26, r30
    308c:	bf 07       	cpc	r27, r31
    308e:	c8 f3       	brcs	.-14     	; 0x3082 <strrev+0x10>
    3090:	08 95       	ret

00003092 <__udivmodhi4>:
    3092:	aa 1b       	sub	r26, r26
    3094:	bb 1b       	sub	r27, r27
    3096:	51 e1       	ldi	r21, 0x11	; 17
    3098:	07 c0       	rjmp	.+14     	; 0x30a8 <__udivmodhi4_ep>

0000309a <__udivmodhi4_loop>:
    309a:	aa 1f       	adc	r26, r26
    309c:	bb 1f       	adc	r27, r27
    309e:	a6 17       	cp	r26, r22
    30a0:	b7 07       	cpc	r27, r23
    30a2:	10 f0       	brcs	.+4      	; 0x30a8 <__udivmodhi4_ep>
    30a4:	a6 1b       	sub	r26, r22
    30a6:	b7 0b       	sbc	r27, r23

000030a8 <__udivmodhi4_ep>:
    30a8:	88 1f       	adc	r24, r24
    30aa:	99 1f       	adc	r25, r25
    30ac:	5a 95       	dec	r21
    30ae:	a9 f7       	brne	.-22     	; 0x309a <__udivmodhi4_loop>
    30b0:	80 95       	com	r24
    30b2:	90 95       	com	r25
    30b4:	bc 01       	movw	r22, r24
    30b6:	cd 01       	movw	r24, r26
    30b8:	08 95       	ret

000030ba <_exit>:
    30ba:	f8 94       	cli

000030bc <__stop_program>:
    30bc:	ff cf       	rjmp	.-2      	; 0x30bc <__stop_program>
